<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Galería — Diagnóstico texturas & fixes (corregido)</title>

  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

  <style> html,body{height:100%;margin:0;background:#000} a-scene{height:100vh;width:100vw} </style>
</head>
<body>
  <a-scene id="scene" background="color:#000000" renderer="antialias:true; physicallyCorrectLights:false" shadow="type:pcfsoft; autoUpdate:true">
    <a-assets>
      <a-asset-item id="cuarto1" src="models/cuarto1.glb"></a-asset-item>
      <a-asset-item id="cuarto2" src="models/cuarto2.glb"></a-asset-item>
      <a-asset-item id="cuarto3" src="models/cuarto3.glb"></a-asset-item>
      <a-asset-item id="cuarto4" src="models/cuarto4.glb"></a-asset-item>
      <a-asset-item id="cuarto5" src="models/cuarto5.glb"></a-asset-item>
      <a-asset-item id="cuarto6" src="models/cuarto6.glb"></a-asset-item>
    </a-assets>

    <!-- una sola instancia del cuarto1 -->
    <a-entity id="cuarto1_ent" gltf-model="#cuarto1" nav-mesh shadow="receive:true"></a-entity>

    <a-entity id="cuarto2_ent" gltf-model="#cuarto2" shadow="receive:true"></a-entity>
    <a-entity id="cuarto3_ent" gltf-model="#cuarto3" shadow="receive:true"></a-entity>
    <a-entity id="cuarto4_ent" gltf-model="#cuarto4" shadow="receive:true"></a-entity>
    <a-entity id="cuarto5_ent" gltf-model="#cuarto5" shadow="receive:true"></a-entity>
    <a-entity id="cuarto6_ent" gltf-model="#cuarto6" shadow="receive:true"></a-entity>

    <a-entity id="lamp" position="0 2.6 0"
              light="type:point; color:#ffffff; intensity:2.0; distance:35; decay:2; castShadow:true"></a-entity>

    <a-entity id="rig" position="0 0 2" movement-controls="constrainToNavMesh:true; controls: checkpoint, gamepad, trackpad, keyboard, nipple;">
      <a-entity camera position="0 1.8 0" look-controls="pointerLockEnabled:true"><a-cursor></a-cursor></a-entity>
    </a-entity>
    
<script>
(function(){
  const sceneEl = document.querySelector('a-scene');
  if (!sceneEl) { console.warn('No a-scene found'); return; }

  // Ajustes globales
  const SHADOW_MAP_TYPE = THREE.PCFSoftShadowMap; // más estable que VSM para este caso
  const TARGET_MIN_TEX = 1024; // tamaño mínimo recomendado para color maps en px
  const MAX_PIXELRATIO = Math.min(window.devicePixelRatio || 1, 2);

  // Helper utilities
  function isPowerOfTwo(v){ return (v & (v - 1)) === 0; }
  function nextPOT(v){ let p=1; while(p<v) p<<=1; return p; }

  // Forzar renderer settings
  sceneEl.addEventListener('render-target-loaded', () => {
    try {
      const renderer = sceneEl.renderer;
      if (!renderer) return;
      renderer.setPixelRatio(MAX_PIXELRATIO);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.physicallyCorrectLights = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = SHADOW_MAP_TYPE;
      console.log('[fix] renderer configured: pixelRatio', renderer.getPixelRatio(), 'shadowMapType', renderer.shadowMap.type);
    } catch(e){ console.warn('[fix] renderer config fail', e); }
  });

  // Promotion de un Material a MeshStandard, manteniendo mapas relevantes
  function promoteToStandard(oldMat, renderer){
    try {
      if (!oldMat) return null;
      if (oldMat.isMeshStandardMaterial) return oldMat;
      const newMat = new THREE.MeshStandardMaterial();
      // Copy relevant maps and props conservatively
      ['map','normalMap','roughnessMap','metalnessMap','aoMap','emissiveMap','alphaMap'].forEach(k=>{
        if (oldMat[k]) newMat[k] = oldMat[k];
      });
      if (oldMat.color) newMat.color.copy(oldMat.color);
      if (oldMat.emissive) newMat.emissive.copy(oldMat.emissive);
      newMat.roughness = (oldMat.roughness !== undefined) ? oldMat.roughness : 1.0;
      newMat.metalness = (oldMat.metalness !== undefined) ? oldMat.metalness : 0.0;
      newMat.side = THREE.DoubleSide;
      newMat.needsUpdate = true;
      return newMat;
    } catch(e){ console.warn('[fix] promote fail', e); return null; }
  }

  // Asegura que una textura sea POT y tenga mipmaps + filtros adecuados
  function ensureTextureGood(tex, key, renderer){
    if (!tex) return {ok:false, reason:'no-tex'};
    const img = tex.image;
    const info = {
      key,
      width: img ? (img.width || img.naturalWidth || img.bitmapWidth || 0) : 0,
      height: img ? (img.height || img.naturalHeight || img.bitmapHeight || 0) : 0,
      isPOT: img ? (isPowerOfTwo(img.width || img.naturalWidth || img.bitmapWidth || 0) && isPowerOfTwo(img.height || img.naturalHeight || img.bitmapHeight || 0)) : false,
      generateMipmaps: !!tex.generateMipmaps
    };
    // force encoding per key
    const colorKeys = ['map','emissiveMap','lightMap','aoMap','alphaMap'];
    const linearKeys = ['normalMap','metalnessMap','roughnessMap','bumpMap','displacementMap'];
    try {
      if (colorKeys.includes(key)) tex.encoding = THREE.sRGBEncoding;
      if (linearKeys.includes(key)) tex.encoding = THREE.LinearEncoding;
    } catch(e){}

    // generate mipmaps / filters if missing (best-effort)
    if (!info.isPOT || !info.generateMipmaps || info.width < TARGET_MIN_TEX || info.height < TARGET_MIN_TEX) {
      // try to upscale with a canvas to a POT size (best effort). This can fail cross-origin.
      try {
        if (img && (img instanceof HTMLImageElement || img instanceof HTMLCanvasElement || (typeof ImageBitmap !== 'undefined' && img instanceof ImageBitmap))) {
          const maxTex = renderer.capabilities && (renderer.capabilities.maxTextureSize || renderer.capabilities.getMaxTextureSize && renderer.capabilities.getMaxTextureSize()) || 4096;
          const desired = Math.min(maxTex, Math.max(TARGET_MIN_TEX, Math.max(info.width, info.height)));
          const target = nextPOT(desired);
          const canvas = document.createElement('canvas');
          canvas.width = target; canvas.height = target;
          const ctx = canvas.getContext('2d');
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          // preserve aspect
          const aspect = (info.width && info.height) ? (info.width / info.height) : 1;
          let dw = target, dh = target;
          if (aspect > 1) dh = Math.round(target / aspect); else dw = Math.round(target * aspect);
          const ox = Math.round((target-dw)/2), oy = Math.round((target-dh)/2);
          ctx.drawImage(img, ox, oy, dw, dh);
          const newTex = new THREE.CanvasTexture(canvas);
          newTex.generateMipmaps = true;
          newTex.minFilter = THREE.LinearMipmapLinearFilter;
          newTex.magFilter = THREE.LinearFilter;
          try { newTex.anisotropy = renderer.capabilities.getMaxAnisotropy(); } catch(e){}
          newTex.wrapS = newTex.wrapT = THREE.RepeatWrapping;
          newTex.needsUpdate = true;
          return {ok:true, replaced:true, newTex};
        }
      } catch(e){
        return {ok:false, reason:'canvas-resize-failed', err:e};
      }
    }

    // ensure filters/mipmaps present
    tex.generateMipmaps = true;
    tex.minFilter = tex.minFilter || THREE.LinearMipmapLinearFilter;
    tex.magFilter = tex.magFilter || THREE.LinearFilter;
    try { tex.anisotropy = tex.anisotropy || (renderer.capabilities && renderer.capabilities.getMaxAnisotropy && renderer.capabilities.getMaxAnisotropy()) || 1; } catch(e){}
    tex.needsUpdate = true;
    return {ok:true, replaced:false, info};
  }

  // Recorre un modelo, imprime problemas y aplica fixes
  function inspectAndFixModel(el){
    const renderer = sceneEl.renderer;
    if (!el) return;
    el.addEventListener('model-loaded', (ev) => {
      try {
        const root = ev.detail.model;
        const problems = [];
        root.traverse(node => {
          if (!node.isMesh) return;
          // ensure normals exist
          if (node.geometry && !node.geometry.attributes.normal) {
            node.geometry.computeVertexNormals();
            problems.push({type:'computedNormals', mesh: node.name || node.id});
          }
          // per material
          const mats = Array.isArray(node.material) ? node.material : [node.material];
          mats.forEach((mat, idx) => {
            if (!mat) return;
            // if BasicMaterial -> promote
            if (mat.isMeshBasicMaterial) {
              const promoted = promoteToStandard(mat, renderer);
              if (promoted) {
                if (Array.isArray(node.material)) node.material[idx] = promoted;
                else node.material = promoted;
                problems.push({type:'promotedBasic', mesh: node.name || node.id, matIndex: idx});
              } else {
                problems.push({type:'basicNoPromote', mesh: node.name || node.id});
              }
            }
            // ensure common maps are good
            ['map','emissiveMap','lightMap','aoMap','normalMap','metalnessMap','roughnessMap'].forEach(k => {
              if (mat[k]) {
                const result = ensureTextureGood(mat[k], k, renderer);
                if (result.ok && result.replaced && result.newTex) {
                  mat[k] = result.newTex;
                  mat.needsUpdate = true;
                  problems.push({type:'replacedTex', mesh: node.name || node.id, key:k, size: result.newTex.image.width + 'x' + result.newTex.image.height});
                } else if (!result.ok) {
                  problems.push({type:'texProblem', mesh: node.name || node.id, key:k, reason: result.reason || ''});
                }
              }
            });
            // ensure receive/cast shadows
            node.castShadow = true;
            node.receiveShadow = true;
          });
        });

        // log summary
        if (problems.length) console.log('[fix] issues found/fixed for', el.id, problems);
        else console.log('[fix] no issues found for', el.id);
      } catch(e){ console.warn('[fix] model inspect fail for', el.id, e); }
    });
    // if already loaded
    const maybe = el.getObject3D('mesh') || el.getObject3D('model');
    if (maybe) el.emit('model-loaded', { model: maybe }, false);
  }

  // Toggle utilities for visual debugging
  window.__aframe_debug = {
    toggleWireframe: function(state){
      sceneEl.object3D.traverse(node=>{
        if (node.isMesh && node.material){
          const mats = Array.isArray(node.material)?node.material:[node.material];
          mats.forEach(m=>{ if (m) m.wireframe = (state===undefined) ? !m.wireframe : !!state; m.needsUpdate=true; });
        }
      });
    },
    onlyAmbient: function(on){
      // toggle off all non-ambient lights
      sceneEl.object3D.traverse(node=>{
        if (node.isLight && node.type!=='AmbientLight'){
          node.visible = !on? true : false;
        }
      });
      console.log('[debug] onlyAmbient=', !!on);
    },
    listMaterials: function(){
      const out=[];
      sceneEl.object3D.traverse(n=>{ if(n.isMesh && n.material) out.push({mesh:n.name||n.id, material:n.material}); });
      console.log(out);
      return out;
    }
  };

  // run for all gltf-model nodes
  const nodes = sceneEl.querySelectorAll('[gltf-model]');
  nodes.forEach(inspectAndFixModel);

  // If user wants immediate debug, expose quick actions in console:
  console.log('[fix] Diagnostics loaded. Use __aframe_debug.toggleWireframe(), __aframe_debug.onlyAmbient(true), __aframe_debug.listMaterials() in the console.');

})();
</script>

  </a-scene>
</body>
</html>
