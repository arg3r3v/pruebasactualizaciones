<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Escena A-Frame Realista</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.6.0/dist/aframe-extras.controls.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

    <style>
      html, body { height:100%; margin:0; background:#000; touch-action: none; -ms-touch-action: none; }
      a-scene { width:100%; height:100vh; display:block; }
      /* botón opcional para lock pointer en desktop (visible solo si hace falta) */
      #lockBtn {
        position: absolute; right: 18px; top: 18px;
        z-index: 9999; padding: 8px 12px; background: rgba(255,255,255,0.06); color:#fff; border-radius:6px; font-family: sans-serif;
        font-size:14px; cursor:pointer;
      }
    </style>
    
  </head>
  <body>
    <a-scene shadow="type: pcfsoft" 
             renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true; toneMapping: ACESFilmic; exposure: 1.0">
      
      <!-- Assets: modelos GLB separados -->
      <a-assets>
        <a-asset-item id="pisoModel" src="models/piso.glb"></a-asset-item>
        <a-asset-item id="paredesModel" src="models/paredes.glb"></a-asset-item>
        <a-asset-item id="techoModel" src="models/techo.glb"></a-asset-item>
        <!-- Otros modelos de assets aquí -->
        <a-asset-item id="cuarto1" src="models/assets1.glb"></a-asset-item>
        <a-asset-item id="cuarto2" src="models/assets2.glb"></a-asset-item>
        <a-asset-item id="cuarto3" src="models/assets3.glb"></a-asset-item>
        <a-asset-item id="cuarto4" src="models/assets4.glb"></a-asset-item>
        <a-asset-item id="cuarto5" src="models/assets5.glb"></a-asset-item>
        <a-asset-item id="cuarto6" src="models/assets6.glb"></a-asset-item>
        <a-asset-item id="cuarto7" src="models/assets7.glb"></a-asset-item>
      </a-assets>

      <!-- Luces: ambiental + direccional -->
      <a-entity id="greenLamp"
          position="-1.5 1.5 -0.75"
          light="type: point; 
                 color: #2bff7a; 
                 intensity: 5; 
                 distance: 30; 
                 decay: 2; 
                 castShadow: true; 
                 shadowMapWidth: 2500; 
                 shadowMapHeight: 2500; 
                 shadowBias: -0.0003">
</a-entity>

      <!-- Modelos GLB cargados -->
      <a-entity gltf-model="#pisoModel" shadow="receive: true"></a-entity>
      <a-entity gltf-model="#paredesModel" shadow="cast: true; receive: true"></a-entity>
      <a-entity gltf-model="#techoModel" shadow="cast: true"></a-entity>
      <!-- otros modelos y entidades aquí -->
      <a-entity id="cuarto1_ent" gltf-model="#cuarto1" shadow="cast: true; receive: true"></a-entity>
      <a-entity id="cuarto2_ent" gltf-model="#cuarto2" shadow="cast: true; receive: true"></a-entity>
      <a-entity id="cuarto3_ent" gltf-model="#cuarto3" shadow="cast: true; receive: true"></a-entity>
      <a-entity id="cuarto4_ent" gltf-model="#cuarto4" shadow="cast: true; receive: true"></a-entity>
      <a-entity id="cuarto5_ent" gltf-model="#cuarto5" shadow="cast: true; receive: true"></a-entity>
      <a-entity id="cuarto6_ent" gltf-model="#cuarto6" shadow="cast: true; receive: true"></a-entity>
      <a-entity id="cuarto7_ent" gltf-model="#cuarto7" shadow="cast: true; receive: true"></a-entity>

      <!-- Cámara y controles -->
      <a-entity id="cameraRig"
                movement-controls="controls: keyboard,gamepad,trackpad,nipple; fly: false; speed: 0.12">
        <a-entity camera position="0 1.5 0" look-controls="pointerLockEnabled: true"> <a-cursor></a-cursor>

    <script>
      // Ajustar materia invisibilidad de plano de sombra al cargar la escena
      document.querySelector('a-scene').addEventListener('loaded', () => {
        const plane = document.querySelector('#shadowPlane');
        const mesh = plane.getObject3D('mesh');
        if (mesh) {
          mesh.material = new THREE.ShadowMaterial({ opacity: 0.5 });
          mesh.material.side = THREE.DoubleSide;
        }
        // Centrado automático: calcular bounding box de los modelos
        const bbox = new THREE.Box3();
        document.querySelectorAll('a-entity[gltf-model]').forEach(ent => {
          const obj = ent.getObject3D('mesh');
          if (obj) bbox.expandByObject(obj);
        });
        const center = bbox.getCenter(new THREE.Vector3());
        const rig = document.querySelector('#cameraRig');
        rig.object3D.position.set(center.x, center.y, center.z);
      });

      // -----------------------
      // 2) mobile-joystick component: usa nipplejs si estamos en dispositivo táctil
      //    mueve el cameraRig directamente (fallback robusto)
      // -----------------------
      AFRAME.registerComponent('mobile-joystick', {
        schema: {
          speed: { type: 'number', default: 0.12 } // metros/segundo
        },
        init: function() {
          this.rig = this.el;
          this.vx = 0;
          this.vz = 0;
          this.active = false;
          this.nipple = null;
          this.lastTime = null;

          // activarse sólo en dispositivos táctiles
          this.isTouch = (('ontouchstart' in window) || navigator.maxTouchPoints > 0 || (window.matchMedia && window.matchMedia('(pointer:coarse)').matches));

          if (!this.isTouch) {
            // mostrar botón de lock para desktop si quieres
            const lb = document.getElementById('lockBtn');
            if (lb) { lb.style.display = 'block'; lb.onclick = () => { document.body.requestPointerLock && document.body.requestPointerLock(); }; }
            return;
          }

          // crear contenedor joystick en DOM
          this.zone = document.createElement('div');
          this.zone.style.position = 'absolute';
          this.zone.style.left = '14px';
          this.zone.style.bottom = '14px';
          this.zone.style.width = '44%';
          this.zone.style.height = '44%';
          this.zone.style.maxWidth = '420px';
          this.zone.style.maxHeight = '420px';
          this.zone.style.zIndex = '9999';
          this.zone.style.touchAction = 'none';
          document.body.appendChild(this.zone);

          // crear joystick con nipplejs
          try {
            this.nipple = nipplejs.create({
              zone: this.zone,
              mode: 'dynamic',
              color: '#fff',
              size: 120,
              restOpacity: 0.25,
              lockX: false,
              lockY: false
            });

            this.nipple.on('start', (evt, data) => {
              this.active = true;
              this.lastTime = performance.now();
            });

            this.nipple.on('end', (evt, data) => {
              this.active = false;
              this.vx = 0; this.vz = 0;
            });

            this.nipple.on('move', (evt, data) => {
              if (!data || !data.vector) return;
              // nipplejs vector: x,y in -1..1
              // mapear joystick a forward/right del rig (en rig local space)
              const nx = data.vector.x || 0; // derecha +
              const ny = data.vector.y || 0; // arriba +
              // invertimos ny para que empuje hacia adelante con el dedo hacia arriba
              this.jx = nx;
              this.jy = -ny;
            });

          } catch (e) {
            console.warn('nipplejs fallo:', e);
          }
        },

        tick: function(time, delta) {
          if (!this.isTouch) return; // solo para móvil
          const dt = (delta || 16) / 1000;
          if (!this.active && (!this.jx && !this.jy)) return;

          // si no hay joystick, nothing
          const jx = this.jx || 0;
          const jy = this.jy || 0;
          if (Math.abs(jx) < 0.01 && Math.abs(jy) < 0.01) return;

          // convertir joystick a movimiento en rig local space (usando la orientación de la cámara)
          const cam = this.rig.querySelector('[camera]');
          let yaw = 0;
          if (cam && cam.object3D) {
            const q = cam.object3D.quaternion;
            const e = new THREE.Euler().setFromQuaternion(q, 'YXZ');
            yaw = e.y;
          } else {
            yaw = this.rig.object3D.rotation.y;
          }

          const dir = new THREE.Vector3(jx, 0, jy).normalize();
          const yawQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0));
          dir.applyQuaternion(yawQ);

          // aplicar movimiento
          const move = dir.multiplyScalar(this.data.speed * dt);
          this.rig.object3D.position.x += move.x;
          this.rig.object3D.position.z += move.z;
        },

        remove: function() {
          if (this.nipple) { this.nipple.destroy(); this.nipple = null; }
          if (this.zone && this.zone.parentNode) this.zone.parentNode.removeChild(this.zone);
        }
      });


      // -----------------------
      // 3) pequeña ayuda: si movement-controls no se inicializó bien, avisar en consola
      // -----------------------
      (function(){
        const rig = document.getElementById('cameraRig');
        setTimeout(()=> {
          if (rig && !rig.components['movement-controls']) {
            console.warn('movement-controls component no disponible en cameraRig — revisa que aframe-extras se haya cargado correctamente.');
          } else {
            console.log('movement-controls OK:', !!(rig && rig.components['movement-controls']));
          }
        }, 1200);
      })();
    </script>
  </body>
</html>
