<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Galería — Cuartos (1 luz interior + sombras, fondo negro)</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

  <style>
    html,body { height:100%; margin:0; background:#000; }
    a-scene { height:100vh; width:100vw; }
  </style>
</head>
<body>
  <a-scene id="scene"
           background="color: #000000"
           renderer="antialias: true; physicallyCorrectLights: true"
           shadow="type: pcfsoft; autoUpdate: true">

    <!-- ASSETS -->
    <a-assets>
      <a-asset-item id="cuarto1" src="models/cuarto1.glb"></a-asset-item>
      <a-asset-item id="cuarto2" src="models/cuarto2.glb"></a-asset-item>
      <a-asset-item id="cuarto3" src="models/cuarto3.glb"></a-asset-item>
      <a-asset-item id="cuarto4" src="models/cuarto4.glb"></a-asset-item>
      <a-asset-item id="cuarto5" src="models/cuarto5.glb"></a-asset-item>
      <a-asset-item id="cuarto6" src="models/cuarto6.glb"></a-asset-item>
    </a-assets>

    <!-- navmesh (cuarto1 es navmesh) -->
    <a-entity id="navmesh" nav-mesh gltf-model="#cuarto1" visible="false"></a-entity>

    <!-- ÚNICA LUZ interior: point light (bombilla).
         mapSize y radius serán ajustados en runtime según plataforma -->
    <a-entity id="lamp"
              position="0 2.6 0"
              light="type: point; color: #ffffff; intensity: 6.0; distance: 40; decay: 2; castShadow: true">
    </a-entity>

    <!-- RIG (movimiento) -->
    <a-entity id="rig" movement-controls="constrainToNavMesh: true; controls: checkpoint, gamepad, trackpad, keyboard, nipple;" position="0 0 2">
      <a-entity camera position="0 1.8 0" look-controls="pointerLockEnabled: true">
        <a-cursor></a-cursor>
      </a-entity>
    </a-entity>

    <!-- Los GLBs — respetan su transformación interna exportada desde Blender -->
    <a-entity id="cuarto1_vis" gltf-model="#cuarto1"></a-entity>
    <a-entity id="cuarto2_vis" gltf-model="#cuarto2"></a-entity>
    <a-entity id="cuarto3_vis" gltf-model="#cuarto3"></a-entity>
    <a-entity id="cuarto4_vis" gltf-model="#cuarto4"></a-entity>
    <a-entity id="cuarto5_vis" gltf-model="#cuarto5"></a-entity>
    <a-entity id="cuarto6_vis" gltf-model="#cuarto6"></a-entity>

    <!-- Script: renderer tweaks, adaptive shadow settings, material fixes, clamp a bbox -->
    <script>
      AFRAME.registerSystem('mobile-friendly-shadows', {
        init: function () {
          const sceneEl = this.el;
          const lamp = document.getElementById('lamp');

          // Detect mobile/simple heuristic
          const ua = navigator.userAgent || '';
          const isMobile = /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/i.test(ua);

          // Tweak values per platform
          const desktopShadowMapSize = 2048;
          const mobileShadowMapSize = 1024;
          const desktopPixelRatioLimit = 2.0;
          const mobilePixelRatioLimit = 1.25;

          const shadowMapSize = isMobile ? mobileShadowMapSize : desktopShadowMapSize;
          const pixelRatioLimit = isMobile ? mobilePixelRatioLimit : desktopPixelRatioLimit;

          // When renderer ready, configure it
          sceneEl.addEventListener('render-target-loaded', () => {
            try {
              const renderer = sceneEl.renderer;
              if (!renderer) return;
              // Limit pixel ratio to avoid extreme GPU/memory on mobile
              const pr = Math.min(window.devicePixelRatio || 1, pixelRatioLimit);
              renderer.setPixelRatio(pr);
              renderer.outputEncoding = THREE.sRGBEncoding;
              renderer.shadowMap.enabled = true;
              renderer.shadowMap.type = THREE.PCFSoftShadowMap;
              renderer.physicallyCorrectLights = true;

              // configure the light's shadow map size and softness
              const light = lamp && lamp.getObject3D('light');
              if (light) {
                light.castShadow = true;
                light.shadow.mapSize.width = shadowMapSize;
                light.shadow.mapSize.height = shadowMapSize;
                // soften edges: radius larger => softer shadows (may be more expensive)
                light.shadow.radius = isMobile ? 1.0 : 2.0;
                // bias to reduce acne
                light.shadow.bias = -0.0006;
              }

              console.log('Renderer configured. isMobile=', isMobile, 'pixelRatio=', pr, 'shadowMapSize=', shadowMapSize);
            } catch (e) {
              console.warn('Error configuring renderer:', e);
            }
          });

          // Material fixes for glTF meshes to avoid "black" materials and ensure textures use sRGB
          function fixMaterial(mesh) {
            if (!mesh || !mesh.material) return;
            const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
            mats.forEach(mat => {
              if (!mat) return;
              try {
                mat.side = THREE.DoubleSide;            // ver desde dentro
                if ('metalness' in mat) mat.metalness = 0.0;
                if ('roughness' in mat) mat.roughness = Math.max(0.9, mat.roughness || 1.0);
                mat.envMap = null;
                mat.envMapIntensity = 0;
                if (mat.map) mat.map.encoding = THREE.sRGBEncoding;
                if (mat.emissiveMap) mat.emissiveMap.encoding = THREE.sRGBEncoding;
                mat.needsUpdate = true;
              } catch (err) {
                // ignore materials we can't touch
              }
            });
          }

          // Prepare any entity with gltf-model: enable shadows and fix materials on model-loaded
          function prepareEntity(el) {
            if (!el) return;
            if (el.setAttribute) el.setAttribute('shadow', 'cast: true; receive: true');
            el.addEventListener('model-loaded', () => {
              const obj = el.getObject3D('mesh') || el.getObject3D('model');
              if (!obj) return;
              obj.traverse(node => {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                  fixMaterial(node);
                }
              });
            });
            // cached
            const maybe = el.getObject3D('mesh') || el.getObject3D('model');
            if (maybe) {
              maybe.traverse(node => {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                  fixMaterial(node);
                }
              });
            }
          }

          // apply to现ent gltf-models
          const gltfs = sceneEl.querySelectorAll('[gltf-model]');
          gltfs.forEach(prepareEntity);

          // observe new nodes
          const mo = new MutationObserver(muts => {
            muts.forEach(m => {
              m.addedNodes.forEach(n => {
                if (!(n instanceof Element)) return;
                if (n.hasAttribute && n.hasAttribute('gltf-model')) prepareEntity(n);
              });
            });
          });
          mo.observe(sceneEl, { childList: true, subtree: true });

          // --- clamp rig to navmesh bounding box to prevent leaving the closed room ---
          const rig = document.getElementById('rig');
          const nav = document.getElementById('navmesh');
          let bbox = null;
          const margin = 0.05;

          function computeBBox() {
            const obj = nav.getObject3D('mesh') || nav.getObject3D('model');
            if (!obj) return null;
            const box = new THREE.Box3().setFromObject(obj);
            return box;
          }

          nav.addEventListener('model-loaded', () => {
            bbox = computeBBox();
            if (bbox) console.log('navmesh bbox:', bbox.min, bbox.max);
          });

          const navNow = nav.getObject3D('mesh') || nav.getObject3D('model');
          if (navNow) bbox = computeBBox();

          sceneEl.addEventListener('tick', () => {
            if (!bbox || !rig) return;
            const p = rig.object3D.position;
            const minX = bbox.min.x + margin, maxX = bbox.max.x - margin;
            const minZ = bbox.min.z + margin, maxZ = bbox.max.z - margin;
            let changed = false;
            if (p.x < minX) { p.x = minX; changed = true; }
            if (p.x > maxX) { p.x = maxX; changed = true; }
            if (p.z < minZ) { p.z = minZ; changed = true; }
            if (p.z > maxZ) { p.z = maxZ; changed = true; }
            if (changed) {
              try {
                const mc = rig.components['movement-controls'];
                if (mc && mc.velocity) mc.velocity.set(0,0,0);
              } catch(e){}
            }
          });

        } // init
      });
    </script>

  </a-scene>
</body>
</html>
