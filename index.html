<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Galería — Corregido (movimiento + centrado + sombras)</title>

  <!-- A-Frame + extras (movement-controls, nipple) -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

  <style> html,body{height:100%;margin:0;background:#000} a-scene{width:100%;height:100vh;display:block} </style>
</head>
<body>
  <a-scene id="scene"
           background="color:#000000"
           embedded
           renderer="antialias:true; physicallyCorrectLights:true; colorManagement:true"
           shadow="type:pcfsoft; autoUpdate:true">

    <a-assets timeout="0">
      <!-- reemplaza con tus GLBs -->
      <a-asset-item id="techo"   src="models/techo.glb"></a-asset-item>
      <a-asset-item id="piso"    src="models/piso.glb"></a-asset-item>
      <a-asset-item id="paredes" src="models/paredes.glb"></a-asset-item>

      <a-asset-item id="assets1" src="models/assets1.glb"></a-asset-item>
      <a-asset-item id="assets2" src="models/assets2.glb"></a-asset-item>
      <a-asset-item id="assets3" src="models/assets3.glb"></a-asset-item>
      <a-asset-item id="assets4" src="models/assets4.glb"></a-asset-item>
      <a-asset-item id="assets5" src="models/assets5.glb"></a-asset-item>
      <a-asset-item id="assets6" src="models/assets6.glb"></a-asset-item>
    </a-assets>

    <!-- ambient tenue -->
    <a-entity light="type:ambient; intensity:0.12; color:#0b0b0b"></a-entity>

    <!-- Luz principal: SPOT (menos ruido que point light cubemap) -->
    <!-- posición solicitada: x:-6 y:2 z:4 -->
    <a-entity id="greenLamp" position="-6 2 4"
              light="type:spot; color:#2bff7a; intensity:144; distance:30; angle:1.2; penumbra:0.6; decay:2; castShadow:true">
    </a-entity>

    <!-- RIG con movement-controls (extras) -->
    <a-entity id="rig"
              movement-controls="constrainToNavMesh: true; controls: checkpoint, gamepad, trackpad, keyboard, nipple"
              position="0 1.6 0">
      <!-- cámara "pequeña" y centrada dentro del rig (se recalcula luego) -->
      <a-entity camera id="camera" position="0 0 0" look-controls="pointerLockEnabled:false; touchEnabled:true"></a-entity>
    </a-entity>

    <!-- Entidades GLB -->
    <a-entity id="techo-entity"   gltf-model="#techo"   shadow="cast:true; receive:true"></a-entity>
    <a-entity id="piso-entity"    gltf-model="#piso"    shadow="cast:true; receive:true"></a-entity>
    <a-entity id="paredes-entity" gltf-model="#paredes" shadow="cast:true; receive:true"></a-entity>

    <a-entity id="asset1-entity" gltf-model="#assets1" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="asset2-entity" gltf-model="#assets2" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="asset3-entity" gltf-model="#assets3" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="asset4-entity" gltf-model="#assets4" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="asset5-entity" gltf-model="#assets5" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="asset6-entity" gltf-model="#assets6" shadow="cast:true; receive:true"></a-entity>

    <!-- receptor de sombras (invisible) que ajustamos al bbox -->
    <a-plane id="shadow-receiver" rotation="-90 0 0" position="0 0 0" width="1" height="1"
             material="color:#000; opacity:0; transparent:true" shadow="receive:true"></a-plane>

  </a-scene>

  <script>
  (function(){
    const scene = document.getElementById('scene');
    if (!scene) return;

    // Parche seguro para evitar sombras enormes que peten GPU: 2048 default, 1024 en mobile
    const MAX_SAFE_SHADOW = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ? 1024 : 2048;
    const CAMERA_HEIGHT = 1.6; // altura "pequeña" por defecto (ajusta si quieres)
    const RIG_MARGIN = 0.05;

    // Utility: esperar a renderer y luego configurar global renderer flags
    scene.addEventListener('render-target-loaded', () => {
      try {
        const renderer = scene.renderer;
        if (!renderer) return;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true;
        renderer.shadowMap.enabled = true;
        // elegir tipo de shadowMap menos ruidoso si existe
        if (THREE.VSMShadowMap) renderer.shadowMap.type = THREE.VSMShadowMap;
        else renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        console.log('[init] renderer ready; shadowMapType=', renderer.shadowMap.type);
      } catch(e){ console.warn('[init] renderer config error', e); }
    });

    // Centrar rig en bbox de techo/piso/paredes cuando estén cargados
    const essentialIds = ['techo-entity','piso-entity','paredes-entity'];
    const loaded = {};
    essentialIds.forEach(id => loaded[id] = false);

    function computeCenterAndPlaceRig() {
      // recoger objetos ya cargados
      const objs = [];
      essentialIds.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        const obj = el.getObject3D('mesh') || el.getObject3D('model') || el.getObject3D('gltf') || el.getObject3D('entity');
        if (obj) objs.push(obj);
      });

      if (!objs.length) {
        // fallback: no mover rig, deja el valor por defecto
        console.warn('[center] no essential models ready yet; leaving rig at default');
        return;
      }

      // expand bbox por cada objeto
      const bbox = new THREE.Box3();
      objs.forEach(o => {
        try { bbox.expandByObject(o); } catch(e) { /* ignore */ }
      });

      if (bbox.isEmpty()) {
        console.warn('[center] bbox empty');
        return;
      }

      const center = new THREE.Vector3(); bbox.getCenter(center);
      const size = new THREE.Vector3(); bbox.getSize(size);
      const baseY = bbox.min.y;

      // colocar rig en el centro y Y sobre el piso + altura de cámara
      const rig = document.getElementById('rig');
      rig.object3D.position.set(center.x, baseY + CAMERA_HEIGHT, center.z);

      // ajustar shadow-receiver al piso
      const plane = document.getElementById('shadow-receiver');
      plane.setAttribute('position', `${center.x} ${baseY + 0.002} ${center.z}`);
      plane.setAttribute('width', Math.max(0.1, size.x));
      plane.setAttribute('height', Math.max(0.1, size.z));

      // set bounds for movement-controls if present
      const margin = RIG_MARGIN;
      const bounds = { minX: bbox.min.x + margin, maxX: bbox.max.x - margin, minZ: bbox.min.z + margin, maxZ: bbox.max.z - margin, minY: baseY + CAMERA_HEIGHT, maxY: baseY + CAMERA_HEIGHT };
      try {
        const rigComp = rig.components && rig.components['movement-controls'];
        if (rigComp && typeof rigComp.setBounds === 'function') rigComp.setBounds(bounds);
      } catch(e){}
      console.log('[center] rig positioned', rig.object3D.position, 'bounds', bounds);
    }

    // Cada essential entity -> esperar model-loaded
    essentialIds.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('model-loaded', () => {
        loaded[id] = true;
        computeCenterAndPlaceRig();
      });
      el.addEventListener('model-error', (ev) => {
        console.warn('[model-error]', id, ev && ev.detail ? ev.detail.src : '');
      });
    });

    // Si ya estaban cargados al arrancar
    setTimeout(computeCenterAndPlaceRig, 300); // intento inicial rápido
    setTimeout(computeCenterAndPlaceRig, 1500); // segundo intento cuando todo haya cargado

    // Configurar sombra del foco greenLamp (mapSize seguro)
    function tuneLamp() {
      const lampEl = document.getElementById('greenLamp');
      if (!lampEl) return;
      const light = lampEl.getObject3D && lampEl.getObject3D('light');
      if (!light) {
        // reintentar un frame después (a veces la light se crea más tarde)
        requestAnimationFrame(tuneLamp);
        return;
      }
      try {
        light.castShadow = true;
        const renderer = scene.renderer;
        const maxAllowed = (renderer && renderer.capabilities && renderer.capabilities.maxTextureSize) || 2048;
        const chosen = Math.min(maxAllowed, MAX_SAFE_SHADOW);
        if (light.shadow && light.shadow.mapSize && typeof light.shadow.mapSize.set === 'function') {
          light.shadow.mapSize.set(chosen, chosen);
        }
        if (light.shadow) {
          light.shadow.bias = -0.0004;
          if ('normalBias' in light) light.normalBias = 0.02;
          if ('radius' in light.shadow) light.shadow.radius = 2.0;
          if (light.shadow.camera && light.shadow.camera.updateProjectionMatrix) {
            light.shadow.camera.near = 0.1;
            light.shadow.camera.far = Math.max(50, (light.distance || 50));
            light.shadow.camera.updateProjectionMatrix();
          }
        }
        // aseguramos que el target exista y esté en el centro (para un spot)
        try {
          if (light.target && light.target.position) {
            // poner target al centro aproximado (0, 1, 0) - luego computeCenterAndPlaceRig actualizará si es necesario
            light.target.position.set(0, 1, 0);
            scene.object3D.add(light.target);
          }
        } catch(e) {}
        console.log('[lamp] tuned, mapSize=', chosen);
      } catch(e){ console.warn('[lamp] tune failed', e); }
    }
    tuneLamp();

    // DEBUG helpers
    window.__aframe_debug = {
      listMaterials: function(){
        const out = [];
        scene.object3D.traverse(n => { if (n.isMesh && n.material) out.push({mesh: n.name || n.id, material: n.material}); });
        console.log(out);
        return out;
      },
      reCenter: computeCenterAndPlaceRig,
      reTuneLamp: tuneLamp
    };

    console.log('[ready] scene helper installed (use __aframe_debug.* in console).');
  })();
  </script>
</body>
</html>
