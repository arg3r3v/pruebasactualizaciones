<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gerardo Arcos - Cuarto con luz interior</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- aframe-extras (movement-controls con nipple/joystick) -->
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
  <!-- physics (cannon + aframe-physics-system) -->
  <script src="https://cdn.jsdelivr.net/gh/schteppe/cannon.js@0.6.2/build/cannon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
  <!-- animation-mixer por si tienes animaciones -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-animation-mixer@6.0.0/dist/aframe-animation-mixer.min.js"></script>

  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="img/logo.png" type="image/png">

  <style>
    body { margin: 0; font-family: sans-serif; }
    header { z-index: 10000; position: relative; padding: 12px 18px; background:#fff; display:flex; align-items:center; gap:12px; }
    header h1 { margin:0; font-size:18px; color:#111; }
    nav ul { margin:0; padding:0; list-style:none; display:flex; gap:10px; }
    a-scene[embedded] { width: 100%; height: 72vh; display: block; }
    #poema { padding: 20px; max-width: 900px; margin: 18px auto; }
    #ui-debug { position: fixed; right: 18px; top: 18px; z-index:9999; }
    #toggle-colliders { background:#111; color:#fff; border: none; padding:8px 12px; border-radius:6px; cursor:pointer; }
    .debug-collider { opacity: 0.22 !important; }
  </style>
</head>
<body>
  <header>
    <h1>GERARDO ARCOS</h1>
    <nav>
      <ul id="nav-list">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="biografia.html">Sobre Mí</a></li>
        <li><a href="proyectos.html">Proyectos</a></li>
        <li><a href="https://arg3r3v.github.io/axolotl/juego.html">Videojuegos</a></li>
      </ul>
    </nav>
  </header>

  <div id="ui-debug">
    <button id="toggle-colliders">Mostrar colliders (D)</button>
  </div>

  <!-- ESCENA: cuarto con luz interior verde -->
  <a-scene embedded
           physics="gravity: 0 -9.8 0"
           shadow="type: pcfsoft"
           renderer="antialias: true; physicallyCorrectLights: true; colorManagement: true">

    <!-- Assets: 6 secciones -->
    <a-assets>
      <a-asset-item id="cuarto1" src="models/cuarto1.glb"></a-asset-item>
      <a-asset-item id="cuarto2" src="models/cuarto2.glb"></a-asset-item>
      <a-asset-item id="cuarto3" src="models/cuarto3.glb"></a-asset-item>
      <a-asset-item id="cuarto4" src="models/cuarto4.glb"></a-asset-item>
      <a-asset-item id="cuarto5" src="models/cuarto5.glb"></a-asset-item>
      <a-asset-item id="cuarto6" src="models/cuarto6.glb"></a-asset-item>
      <!-- personaje opcional -->
      <a-asset-item id="personajeModel" src="models/personaje.glb"></a-asset-item>
    </a-assets>

    <!-- Ambiente muy tenue -->
    <a-entity light="type: ambient; intensity: 0.06; color: #080808"></a-entity>

    <!-- LUZ INTERIOR VERDE (point + spot) -->
    <!-- Posición cambiada a x:6 y:2 z:4 y ~10x intensidad -->
    <a-entity id="greenLamp"
              light="type: point; color: #2bff7a; intensity: 18; distance: 12; decay: 2"
              position="-6 4 8"></a-entity>

    <a-entity id="greenSpot"
              light="type: spot; color: #2bff7a; intensity: 9; distance: 12; angle: 0.8; penumbra: 0.6; decay: 2"
              position="-6 4 8" rotation="-90 0 0"></a-entity>

    <!-- RIG para movimiento (joystick on mobile + WASD desktop) -->
    <a-entity id="rig"
              position="0 1.6 4"
              kinematic-body
              movement-controls="controls: gamepad, trackpad, keyboard, nipple">
      <a-entity id="cam"
                camera
                look-controls="touchEnabled: true; magicWindowTrackingEnabled: true; pointerLockEnabled: true">
        <a-entity cursor="rayOrigin: mouse" raycaster="objects: .clickable"></a-entity>
      </a-entity>
    </a-entity>

    <!-- MODELOS: 6 secciones (visual only). Colliders se crean automáticamente desde JS -->
    <a-entity id="sec1" gltf-model="#cuarto1" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec2" gltf-model="#cuarto2" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec3" gltf-model="#cuarto3" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec4" gltf-model="#cuarto4" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec5" gltf-model="#cuarto5" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec6" gltf-model="#cuarto6" position="0 0 0" shadow="cast: true; receive: true"></a-entity>

    <!-- Personaje decorativo (opcional) -->
    <a-entity id="personaje" gltf-model="#personajeModel" position="1 0 -2" scale="1 1 1" animation-mixer="clip: *; loop: repeat" shadow="cast: true"></a-entity>

  </a-scene>

  <!-- Contenido HTML fuera de la escena -->
  <div id="poema">
    <h2>PORQUE AÚN SOY JOVEN</h2>
    <p class="poem">
      Porque aún soy joven, y algo necio,<br>
      Aún soy joven para errar sin malicia,<br>
      Para amar con verdad y sin prisa,<br>
      Para aprender lo que el tiempo avisa,<br>
      Y perderme en charlas de risa,<br>
      En conversaciones sin juicio.
    </p>
  </div>

  <!-- Script: genera colliders invisibles (a-box static-body) a partir del bounding box de cada sección -->
  <script>
(function(){
  // -------------------------------------------------
  // CONFIG (cámbialo si quieres otra posición/int)
  // -------------------------------------------------
  const DESIRED_LIGHT_POS = new THREE.Vector3(-6, 2, 4); // posición deseada en world coords
  const POINT_INTENSITY_MULT = 1; // ya aumentaste intensidad en HTML; dejar 1
  const LAMP_NAME_CANDIDATES = ['lamp','lampara','light','bulb','bombilla','lampholder','lamp_head','lampara_geo','lampara_']; // substrings para buscar
  const SECTION_IDS = ['sec1','sec2','sec3','sec4','sec5','sec6']; // tus entidades
  // -------------------------------------------------

  const sceneEl = document.querySelector('a-scene');
  const greenPointEl = document.getElementById('greenLamp');
  const greenSpotEl  = document.getElementById('greenSpot');

  function enableShadowsOnModel(model) {
    model.traverse(node => {
      if (node.isMesh) {
        node.castShadow = true;
        node.receiveShadow = true;
        if (node.material) node.material.needsUpdate = true;
      }
    });
  }

  // Busca una mesh que parezca lámpara dentro del model (nombre contiene algun candidato)
  function findLampMesh(model) {
    let found = null;
    model.traverse(node => {
      if (found) return;
      if (node.isMesh && node.name) {
        const n = node.name.toLowerCase();
        for (const cand of LAMP_NAME_CANDIDATES) {
          if (n.includes(cand)) { found = node; break; }
        }
      }
    });
    return found;
  }

  // Mueve la luz (elemento A-Frame) a la posición global deseada
  function setLightPosition(el, vec3) {
    if (!el) return;
    el.setAttribute('position', `${vec3.x.toFixed(3)} ${vec3.y.toFixed(3)} ${vec3.z.toFixed(3)}`);
  }

  // Mueve la malla de la lampara dentro de su jerarquía para que su world position sea igual a desiredPos
  function moveMeshToWorldPosition(mesh, desiredWorldPos) {
    if (!mesh) return false;
    const parent = mesh.parent;
    if (!parent) return false;
    // convert desired world pos to parent's local space
    const localPos = new THREE.Vector3();
    parent.worldToLocal(localPos.copy(desiredWorldPos));
    // set mesh.position (local)
    mesh.position.copy(localPos);
    // actualizar matrices
    mesh.updateMatrix();
    mesh.updateMatrixWorld(true);
    return true;
  }

  // Ajustar shadow map quality en three.js para las luces indicadas
  function boostShadowQuality(lightElId) {
    const el = document.getElementById(lightElId);
    if (!el) return;
    setTimeout(()=>{
      const lightObj = el.getObject3D('light');
      if (!lightObj) return;
      lightObj.castShadow = true;
      if (lightObj.shadow) {
        // resolución razonable por defecto: 2048 (subir si tu GPU aguanta)
        lightObj.shadow.mapSize.width = 2048;
        lightObj.shadow.mapSize.height = 2048;
        lightObj.shadow.bias = -0.0005;
        if (lightObj.shadow.camera) {
          lightObj.shadow.camera.near = 0.1;
          lightObj.shadow.camera.far = 50;
          // para spot/directional ajustamos frustum/camera si existe
          if (lightObj.shadow.camera.left !== undefined) {
            const s = 8;
            lightObj.shadow.camera.left = -s;
            lightObj.shadow.camera.right = s;
            lightObj.shadow.camera.top = s;
            lightObj.shadow.camera.bottom = -s;
          }
          lightObj.shadow.camera.updateProjectionMatrix();
        }
      }
    }, 200);
  }

  // MAIN: procesar cada sección cuando cargue
  SECTION_IDS.forEach(id => {
    const ent = document.getElementById(id);
    if (!ent) return;
    ent.addEventListener('model-loaded', (ev) => {
      try {
        const model = ev.detail.model; // THREE.Object3D root
        // 1) habilitar sombras en todos los meshes (piso incl.)
        enableShadowsOnModel(model);

        // 2) buscar si dentro de este model existe la malla de la lampara
        const lampMesh = findLampMesh(model);
        if (lampMesh) {
          // mover la malla para que coincida con DESIRED_LIGHT_POS (world)
          const moved = moveMeshToWorldPosition(lampMesh, DESIRED_LIGHT_POS);
          console.log(`Lamp mesh encontrada en ${id} (${lampMesh.name}), moved: ${moved}`);
          // opcional: si quieres ajustar orientación, puedes rotar mesh.rotation.set(...)
        }
      } catch (err) {
        console.warn('Error al procesar model-loaded', id, err);
      }
    }, { once: true });
  });

  // Si modelos ya estaban cacheados/ya cargados antes del listener
  window.addEventListener('load', () => {
    SECTION_IDS.forEach(id => {
      const ent = document.getElementById(id);
      if (!ent) return;
      const obj = ent.getObject3D('mesh') || ent.getObject3D('gltf') || ent.getObject3D('object3D');
      if (obj) {
        // emular evento
        ent.emit('model-loaded', { model: obj }, false);
      }
    });

    // 3) colocar las luces en la posición deseada (independiente de las mallas)
    setLightPosition(greenPointEl, DESIRED_LIGHT_POS);
    setLightPosition(greenSpotEl, DESIRED_LIGHT_POS);

    // 4) forzar renderer settings
    const renderer = sceneEl.renderer;
    if (renderer) {
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;
    }

    // 5) boost shadowmap para las luces (ajusta si hace falta)
    boostShadowQuality('greenLamp');
    boostShadowQuality('greenSpot');

    // 6) debug: crea esfera amarilla pequeña en la posición de la luz para que veas dónde quedó
    const debugSphere = document.createElement('a-sphere');
    debugSphere.setAttribute('position', `${DESIRED_LIGHT_POS.x} ${DESIRED_LIGHT_POS.y} ${DESIRED_LIGHT_POS.z}`);
    debugSphere.setAttribute('radius', '0.06');
    debugSphere.setAttribute('color', '#ffff66');
    debugSphere.setAttribute('opacity','0.9');
    debugSphere.setAttribute('id','lamp-debug-sphere');
    sceneEl.appendChild(debugSphere);
    // quitar tras 6s
    setTimeout(()=>{ const d=document.getElementById('lamp-debug-sphere'); if(d && d.parentNode) d.parentNode.removeChild(d); }, 6000);

    console.log('Posicionamiento de luz aplicado en', DESIRED_LIGHT_POS);
  });

})();
</script>

  <!-- opcional: ajustar shadow map size para luces para mejorar calidad (puede afectar rendimiento) -->
  <script>
    document.addEventListener('render-target-loaded', () => {
      try {
        const sceneEl = document.querySelector('a-scene');
        const renderer = sceneEl.renderer;
        if (!renderer) return;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // aumenta resolución de shadow maps para las luces indicadas
        const setShadowQuality = (id) => {
          const lightEl = document.getElementById(id);
          if (!lightEl) return;
          const lightObj = lightEl.getObject3D('light');
          if (!lightObj) return;
          lightObj.castShadow = true;
          if (lightObj.shadow && lightObj.shadow.mapSize) {
            lightObj.shadow.mapSize.width = 2048;
            lightObj.shadow.mapSize.height = 2048;
            lightObj.shadow.bias = -0.0005;
            if (lightObj.shadow.camera) {
              lightObj.shadow.camera.near = 0.1;
              lightObj.shadow.camera.far = 30;
              if (lightObj.shadow.camera.left !== undefined) {
                const s = 6;
                lightObj.shadow.camera.left = -s;
                lightObj.shadow.camera.right = s;
                lightObj.shadow.camera.top = s;
                lightObj.shadow.camera.bottom = -s;
              }
              lightObj.shadow.camera.updateProjectionMatrix();
            }
          }
        };

        setShadowQuality('greenLamp');
        setShadowQuality('greenSpot');
      } catch (err) {
        console.warn('No se pudo ajustar shadow maps:', err);
      }
    });
  </script>

  <script defer src="script.js"></script>
</body>
</html>
