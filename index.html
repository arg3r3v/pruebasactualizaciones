<script>
(function(){
  // Ejecutar cuando el renderer esté disponible
  const runWhenReady = () => {
    const sceneEl = document.querySelector('a-scene');
    if (!sceneEl) { console.warn('No a-scene'); return; }

    // Tus luces / entidades (asegúrate que IDs coincidan)
    const greenPointEl = document.getElementById('greenLamp');
    const greenSpotEl  = document.getElementById('greenSpot');

    // Parámetros que ajustamos (si quieres, cambia)
    const SHADOW_MAP_SIZE = 2048; // 2048 es buen balance; 4096 = más detalle pero caro
    const SHADOW_BIAS = -0.0005;
    const LIGHT_DISTANCE = 20; // asegurar que la luz alcance el piso
    const SPOT_ANGLE = 1.0;
    const FORCE_DOUBLE_SIDE = true;

    // Utilidades
    function setLightParams(el) {
      if (!el) return;
      setTimeout(()=>{ // esperar a que three cree el objeto
        const lightObj = el.getObject3D && el.getObject3D('light');
        if (!lightObj) { console.warn('light object no encontrado para', el.id); return; }
        lightObj.castShadow = true;
        if (lightObj.shadow) {
          lightObj.shadow.mapSize.width = SHADOW_MAP_SIZE;
          lightObj.shadow.mapSize.height = SHADOW_MAP_SIZE;
          lightObj.shadow.bias = SHADOW_BIAS;
          // punto: ajustar far (para pointlights)
          if (typeof lightObj.shadow.camera !== 'undefined') {
            lightObj.shadow.camera.near = 0.1;
            lightObj.shadow.camera.far = 100;
            if (lightObj.shadow.camera.updateProjectionMatrix) lightObj.shadow.camera.updateProjectionMatrix();
          }
        }
        // aumentar distancia si existe (point/spot)
        if ('distance' in lightObj) lightObj.distance = LIGHT_DISTANCE;
        if (lightObj.isSpotLight) {
          lightObj.angle = SPOT_ANGLE;
        }
        console.log('Light params aplicados a', el.id);
      }, 200);
    }

    // Reemplaza un MeshBasicMaterial (unlit) por un MeshStandardMaterial copiando texturas
    function makeMaterialPBR(oldMat) {
      if (!oldMat) return null;
      // If it's already standard, keep it
      if (oldMat.isMeshStandardMaterial) {
        oldMat.needsUpdate = true;
        return oldMat;
      }
      // Create new standard material and copy maps & basic props
      const params = {};
      if (oldMat.map) params.map = oldMat.map;
      if (oldMat.normalMap) params.normalMap = oldMat.normalMap;
      if (oldMat.roughnessMap) params.roughnessMap = oldMat.roughnessMap;
      if (oldMat.metalnessMap) params.metalnessMap = oldMat.metalnessMap;
      if (oldMat.aoMap) params.aoMap = oldMat.aoMap;
      // try copy color if exists
      if (oldMat.color) params.color = oldMat.color.clone();
      // conservative defaults
      params.roughness = (typeof oldMat.roughness !== 'undefined') ? oldMat.roughness : 1.0;
      params.metalness = (typeof oldMat.metalness !== 'undefined') ? oldMat.metalness : 0.0;

      const newMat = new THREE.MeshStandardMaterial(params);
      // keep doubleSided if requested
      if (FORCE_DOUBLE_SIDE) newMat.side = THREE.DoubleSide;
      newMat.needsUpdate = true;
      return newMat;
    }

    // Detectar candidatos a floor: por nombre o por mayor area XZ
    function detectFloorCandidates() {
      const meshes = [];
      sceneEl.object3D.traverse(node => {
        if (node.isMesh) meshes.push(node);
      });
      if (meshes.length === 0) { console.warn('No se encontraron meshes en escena'); return []; }

      // buscar por nombre heurístico
      const lower = ['floor','piso','ground','tile','tiles','suelo','floor_plane'];
      const byName = meshes.filter(m => {
        if (!m.name) return false;
        const n = m.name.toLowerCase();
        return lower.some(k => n.includes(k));
      });
      if (byName.length) {
        console.log('Pisos encontrados por nombre:', byName.map(m=>m.name));
        return byName;
      }

      // si no hay por nombre, elegir las 1-2 meshes con mayor área XZ (bounding box)
      const meshAreas = meshes.map(m => {
        const bb = new THREE.Box3().setFromObject(m);
        const size = new THREE.Vector3(); bb.getSize(size);
        const area = size.x * size.z;
        return { m, area, size, name: m.name || '(unnamed)' };
      });
      meshAreas.sort((a,b)=>b.area-a.area);
      const top = meshAreas.slice(0,2).map(x => x.m);
      console.log('Pisos detectados por tamaño (top):', meshAreas.slice(0,3).map(x=>({name:x.name,area:x.area,size:x.size})));
      return top;
    }

    // Forzar receiveShadow y reemplazar material si es necesario
    function fixFloorMesh(mesh) {
      console.log('Procesando posible piso:', mesh.name || mesh.uuid);
      mesh.receiveShadow = true;
      mesh.castShadow = false; // el piso normalmente no castea sombras

      // comprobar material(s)
      if (Array.isArray(mesh.material)) {
        mesh.material.forEach((mat, i) => {
          if (mat && mat.isMeshBasicMaterial) {
            const newMat = makeMaterialPBR(mat);
            if (newMat) {
              mesh.material[i] = newMat;
              console.log(`Material del submesh ${i} (basic) reemplazado por MeshStandardMaterial`);
            }
          } else if (mat && !mat.isMeshStandardMaterial) {
            // otros tipos: intentar promover a standard conservando mapas
            const newMat = makeMaterialPBR(mat);
            if (newMat) mesh.material[i] = newMat;
          }
          if (mesh.material[i]) {
            mesh.material[i].needsUpdate = true;
            mesh.material[i].side = THREE.DoubleSide; // evitar problemas de normales invertidas
          }
        });
      } else {
        const mat = mesh.material;
        if (mat && mat.isMeshBasicMaterial) {
          const newMat = makeMaterialPBR(mat);
          if (newMat) mesh.material = newMat;
          console.log('Material del piso reemplazado por MeshStandardMaterial (era MeshBasicMaterial)');
        } else if (mat && !mat.isMeshStandardMaterial) {
          // promover si no es standard
          const newMat = makeMaterialPBR(mat);
          if (newMat) mesh.material = newMat;
        }
        if (mesh.material) {
          mesh.material.needsUpdate = true;
          mesh.material.side = THREE.DoubleSide;
        }
      }

      // Forzar recompute normals si están raras
      if (mesh.geometry && mesh.geometry.attributes && !mesh.geometry.attributes.normal) {
        mesh.geometry.computeVertexNormals();
      }
      console.log('Piso preparado para recibir sombras.');
    }

    // MAIN
    try {
      // 1) force renderer settings
      if (sceneEl.renderer) {
        sceneEl.renderer.shadowMap.enabled = true;
        sceneEl.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        sceneEl.renderer.outputEncoding = THREE.sRGBEncoding;
      }

      // 2) set params on lights
      setLightParams(greenPointEl);
      setLightParams(greenSpotEl);

      // 3) find floors and patch them
      // wait a tick to ensure glTF models loaded
      setTimeout(() => {
        const floors = detectFloorCandidates();
        if (floors.length === 0) {
          console.warn('No se detectó piso por nombre ni por tamaño. Intenta inspeccionar nombres de meshes en el glTF viewer.');
        }
        floors.forEach(f => fixFloorMesh(f));
      }, 500);

      // 4) also traverse each loaded model and enable cast/receive on all meshes (safety)
      setTimeout(() => {
        sceneEl.object3D.traverse(node => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = node.receiveShadow || false; // no sobreescribir piso decision

            // If any mesh uses MeshBasicMaterial (unlit) and we want it lit, convert
            if (node.material && node.material.isMeshBasicMaterial) {
              // Convert but keep textures
              const newMat = makeMaterialPBR(node.material);
              if (newMat) node.material = newMat;
            }
          }
        });
        console.log('Force cast/receive en todos los meshes aplicado.');
      }, 900);

      // 5) Final notice:
      console.log('Script de debug y corrección de piso/sombras: ejecutado. Revisa la consola para mensajes detallados.');
    } catch (err) {
      console.error('Error al intentar corregir sombras en piso:', err);
    }
  };

  // Ejecutar cuando Three/renderer listos
  if (document.readyState === 'complete') runWhenReady();
  else window.addEventListener('load', runWhenReady);
})();
</script>
