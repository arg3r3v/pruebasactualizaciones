<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gerardo Arcos - Cuarto con luz interior</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- aframe-extras (movement-controls con nipple/joystick) -->
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
  <!-- physics (cannon + aframe-physics-system) -->
  <script src="https://cdn.jsdelivr.net/gh/schteppe/cannon.js@0.6.2/build/cannon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
  <!-- animation-mixer por si tienes animaciones -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-animation-mixer@6.0.0/dist/aframe-animation-mixer.min.js"></script>

  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="img/logo.png" type="image/png">

  <style>
    body { margin: 0; font-family: sans-serif; }
    header { z-index: 10000; position: relative; padding: 12px 18px; background:#fff; display:flex; align-items:center; gap:12px; }
    header h1 { margin:0; font-size:18px; color:#111; }
    nav ul { margin:0; padding:0; list-style:none; display:flex; gap:10px; }
    a-scene[embedded] { width: 100%; height: 72vh; display: block; }
    #poema { padding: 20px; max-width: 900px; margin: 18px auto; }
    #ui-debug { position: fixed; right: 18px; top: 18px; z-index:9999; }
    #toggle-colliders { background:#111; color:#fff; border: none; padding:8px 12px; border-radius:6px; cursor:pointer; }
    .debug-collider { opacity: 0.22 !important; }
  </style>
</head>
<body>
  <header>
    <h1>GERARDO ARCOS</h1>
    <nav>
      <ul id="nav-list">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="biografia.html">Sobre Mí</a></li>
        <li><a href="proyectos.html">Proyectos</a></li>
        <li><a href="https://arg3r3v.github.io/axolotl/juego.html">Videojuegos</a></li>
      </ul>
    </nav>
  </header>

  <div id="ui-debug">
    <button id="toggle-colliders">Mostrar colliders (D)</button>
  </div>

  <!-- ESCENA: cuarto con luz interior verde -->
  <a-scene embedded
           physics="gravity: 0 -9.8 0"
           shadow="type: pcfsoft"
           renderer="antialias: true; physicallyCorrectLights: true; colorManagement: true">

    <!-- Assets: 6 secciones -->
    <a-assets>
      <a-asset-item id="cuarto1" src="models/cuarto1.glb"></a-asset-item>
      <a-asset-item id="cuarto2" src="models/cuarto2.glb"></a-asset-item>
      <a-asset-item id="cuarto3" src="models/cuarto3.glb"></a-asset-item>
      <a-asset-item id="cuarto4" src="models/cuarto4.glb"></a-asset-item>
      <a-asset-item id="cuarto5" src="models/cuarto5.glb"></a-asset-item>
      <a-asset-item id="cuarto6" src="models/cuarto6.glb"></a-asset-item>
      <!-- personaje opcional -->
      <a-asset-item id="personajeModel" src="models/personaje.glb"></a-asset-item>
    </a-assets>

    <!-- Ambiente muy tenue -->
    <a-entity light="type: ambient; intensity: 0.06; color: #080808"></a-entity>

    <!-- LUZ INTERIOR VERDE (point + spot) -->
    <!-- Posición cambiada a x:6 y:2 z:4 y ~10x intensidad -->
    <a-entity id="greenLamp"
              light="type: point; color: #2bff7a; intensity: 18; distance: 12; decay: 2"
              position="-6 4 8"></a-entity>

    <a-entity id="greenSpot"
              light="type: spot; color: #2bff7a; intensity: 9; distance: 12; angle: 0.8; penumbra: 0.6; decay: 2"
              position="-6 4 8" rotation="-90 0 0"></a-entity>

    <!-- RIG para movimiento (joystick on mobile + WASD desktop) -->
    <a-entity id="rig"
              position="0 1.6 4"
              kinematic-body
              movement-controls="controls: gamepad, trackpad, keyboard, nipple">
      <a-entity id="cam"
                camera
                look-controls="touchEnabled: true; magicWindowTrackingEnabled: true; pointerLockEnabled: true">
        <a-entity cursor="rayOrigin: mouse" raycaster="objects: .clickable"></a-entity>
      </a-entity>
    </a-entity>

    <!-- MODELOS: 6 secciones (visual only). Colliders se crean automáticamente desde JS -->
    <a-entity id="sec1" gltf-model="#cuarto1" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec2" gltf-model="#cuarto2" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec3" gltf-model="#cuarto3" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec4" gltf-model="#cuarto4" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec5" gltf-model="#cuarto5" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec6" gltf-model="#cuarto6" position="0 0 0" shadow="cast: true; receive: true"></a-entity>

    <!-- Personaje decorativo (opcional) -->
    <a-entity id="personaje" gltf-model="#personajeModel" position="1 0 -2" scale="1 1 1" animation-mixer="clip: *; loop: repeat" shadow="cast: true"></a-entity>

  </a-scene>

  <!-- Contenido HTML fuera de la escena -->
  <div id="poema">
    <h2>PORQUE AÚN SOY JOVEN</h2>
    <p class="poem">
      Porque aún soy joven, y algo necio,<br>
      Aún soy joven para errar sin malicia,<br>
      Para amar con verdad y sin prisa,<br>
      Para aprender lo que el tiempo avisa,<br>
      Y perderme en charlas de risa,<br>
      En conversaciones sin juicio.
    </p>
  </div>

  <!-- Script: genera colliders invisibles (a-box static-body) a partir del bounding box de cada sección -->
<script>
(function(){
  // Ejecutar cuando el renderer esté disponible
  const runWhenReady = () => {
    const sceneEl = document.querySelector('a-scene');
    if (!sceneEl) { console.warn('No a-scene'); return; }

    // Tus luces / entidades (asegúrate que IDs coincidan)
    const greenPointEl = document.getElementById('greenLamp');
    const greenSpotEl  = document.getElementById('greenSpot');

    // Parámetros que ajustamos (si quieres, cambia)
    const SHADOW_MAP_SIZE = 2048; // 2048 es buen balance; 4096 = más detalle pero caro
    const SHADOW_BIAS = -0.0005;
    const LIGHT_DISTANCE = 20; // asegurar que la luz alcance el piso
    const SPOT_ANGLE = 1.0;
    const FORCE_DOUBLE_SIDE = true;

    // Utilidades
    function setLightParams(el) {
      if (!el) return;
      setTimeout(()=>{ // esperar a que three cree el objeto
        const lightObj = el.getObject3D && el.getObject3D('light');
        if (!lightObj) { console.warn('light object no encontrado para', el.id); return; }
        lightObj.castShadow = true;
        if (lightObj.shadow) {
          lightObj.shadow.mapSize.width = SHADOW_MAP_SIZE;
          lightObj.shadow.mapSize.height = SHADOW_MAP_SIZE;
          lightObj.shadow.bias = SHADOW_BIAS;
          // punto: ajustar far (para pointlights)
          if (typeof lightObj.shadow.camera !== 'undefined') {
            lightObj.shadow.camera.near = 0.1;
            lightObj.shadow.camera.far = 100;
            if (lightObj.shadow.camera.updateProjectionMatrix) lightObj.shadow.camera.updateProjectionMatrix();
          }
        }
        // aumentar distancia si existe (point/spot)
        if ('distance' in lightObj) lightObj.distance = LIGHT_DISTANCE;
        if (lightObj.isSpotLight) {
          lightObj.angle = SPOT_ANGLE;
        }
        console.log('Light params aplicados a', el.id);
      }, 200);
    }

    // Reemplaza un MeshBasicMaterial (unlit) por un MeshStandardMaterial copiando texturas
    function makeMaterialPBR(oldMat) {
      if (!oldMat) return null;
      // If it's already standard, keep it
      if (oldMat.isMeshStandardMaterial) {
        oldMat.needsUpdate = true;
        return oldMat;
      }
      // Create new standard material and copy maps & basic props
      const params = {};
      if (oldMat.map) params.map = oldMat.map;
      if (oldMat.normalMap) params.normalMap = oldMat.normalMap;
      if (oldMat.roughnessMap) params.roughnessMap = oldMat.roughnessMap;
      if (oldMat.metalnessMap) params.metalnessMap = oldMat.metalnessMap;
      if (oldMat.aoMap) params.aoMap = oldMat.aoMap;
      // try copy color if exists
      if (oldMat.color) params.color = oldMat.color.clone();
      // conservative defaults
      params.roughness = (typeof oldMat.roughness !== 'undefined') ? oldMat.roughness : 1.0;
      params.metalness = (typeof oldMat.metalness !== 'undefined') ? oldMat.metalness : 0.0;

      const newMat = new THREE.MeshStandardMaterial(params);
      // keep doubleSided if requested
      if (FORCE_DOUBLE_SIDE) newMat.side = THREE.DoubleSide;
      newMat.needsUpdate = true;
      return newMat;
    }

    // Detectar candidatos a floor: por nombre o por mayor area XZ
    function detectFloorCandidates() {
      const meshes = [];
      sceneEl.object3D.traverse(node => {
        if (node.isMesh) meshes.push(node);
      });
      if (meshes.length === 0) { console.warn('No se encontraron meshes en escena'); return []; }

      // buscar por nombre heurístico
      const lower = ['floor','piso','ground','tile','tiles','suelo','floor_plane'];
      const byName = meshes.filter(m => {
        if (!m.name) return false;
        const n = m.name.toLowerCase();
        return lower.some(k => n.includes(k));
      });
      if (byName.length) {
        console.log('Pisos encontrados por nombre:', byName.map(m=>m.name));
        return byName;
      }

      // si no hay por nombre, elegir las 1-2 meshes con mayor área XZ (bounding box)
      const meshAreas = meshes.map(m => {
        const bb = new THREE.Box3().setFromObject(m);
        const size = new THREE.Vector3(); bb.getSize(size);
        const area = size.x * size.z;
        return { m, area, size, name: m.name || '(unnamed)' };
      });
      meshAreas.sort((a,b)=>b.area-a.area);
      const top = meshAreas.slice(0,2).map(x => x.m);
      console.log('Pisos detectados por tamaño (top):', meshAreas.slice(0,3).map(x=>({name:x.name,area:x.area,size:x.size})));
      return top;
    }

    // Forzar receiveShadow y reemplazar material si es necesario
    function fixFloorMesh(mesh) {
      console.log('Procesando posible piso:', mesh.name || mesh.uuid);
      mesh.receiveShadow = true;
      mesh.castShadow = false; // el piso normalmente no castea sombras

      // comprobar material(s)
      if (Array.isArray(mesh.material)) {
        mesh.material.forEach((mat, i) => {
          if (mat && mat.isMeshBasicMaterial) {
            const newMat = makeMaterialPBR(mat);
            if (newMat) {
              mesh.material[i] = newMat;
              console.log(`Material del submesh ${i} (basic) reemplazado por MeshStandardMaterial`);
            }
          } else if (mat && !mat.isMeshStandardMaterial) {
            // otros tipos: intentar promover a standard conservando mapas
            const newMat = makeMaterialPBR(mat);
            if (newMat) mesh.material[i] = newMat;
          }
          if (mesh.material[i]) {
            mesh.material[i].needsUpdate = true;
            mesh.material[i].side = THREE.DoubleSide; // evitar problemas de normales invertidas
          }
        });
      } else {
        const mat = mesh.material;
        if (mat && mat.isMeshBasicMaterial) {
          const newMat = makeMaterialPBR(mat);
          if (newMat) mesh.material = newMat;
          console.log('Material del piso reemplazado por MeshStandardMaterial (era MeshBasicMaterial)');
        } else if (mat && !mat.isMeshStandardMaterial) {
          // promover si no es standard
          const newMat = makeMaterialPBR(mat);
          if (newMat) mesh.material = newMat;
        }
        if (mesh.material) {
          mesh.material.needsUpdate = true;
          mesh.material.side = THREE.DoubleSide;
        }
      }

      // Forzar recompute normals si están raras
      if (mesh.geometry && mesh.geometry.attributes && !mesh.geometry.attributes.normal) {
        mesh.geometry.computeVertexNormals();
      }
      console.log('Piso preparado para recibir sombras.');
    }

    // MAIN
    try {
      // 1) force renderer settings
      if (sceneEl.renderer) {
        sceneEl.renderer.shadowMap.enabled = true;
        sceneEl.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        sceneEl.renderer.outputEncoding = THREE.sRGBEncoding;
      }

      // 2) set params on lights
      setLightParams(greenPointEl);
      setLightParams(greenSpotEl);

      // 3) find floors and patch them
      // wait a tick to ensure glTF models loaded
      setTimeout(() => {
        const floors = detectFloorCandidates();
        if (floors.length === 0) {
          console.warn('No se detectó piso por nombre ni por tamaño. Intenta inspeccionar nombres de meshes en el glTF viewer.');
        }
        floors.forEach(f => fixFloorMesh(f));
      }, 500);

      // 4) also traverse each loaded model and enable cast/receive on all meshes (safety)
      setTimeout(() => {
        sceneEl.object3D.traverse(node => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = node.receiveShadow || false; // no sobreescribir piso decision

            // If any mesh uses MeshBasicMaterial (unlit) and we want it lit, convert
            if (node.material && node.material.isMeshBasicMaterial) {
              // Convert but keep textures
              const newMat = makeMaterialPBR(node.material);
              if (newMat) node.material = newMat;
            }
          }
        });
        console.log('Force cast/receive en todos los meshes aplicado.');
      }, 900);

      // 5) Final notice:
      console.log('Script de debug y corrección de piso/sombras: ejecutado. Revisa la consola para mensajes detallados.');
    } catch (err) {
      console.error('Error al intentar corregir sombras en piso:', err);
    }
  };

  // Ejecutar cuando Three/renderer listos
  if (document.readyState === 'complete') runWhenReady();
  else window.addEventListener('load', runWhenReady);
})();
</script>

  <script defer src="script.js"></script>
</body>
</html>
