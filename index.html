<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gerardo Arcos - Cuarto con luz interior</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- aframe-extras (movement-controls con nipple/joystick) -->
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
  <!-- physics (cannon + aframe-physics-system) -->
  <script src="https://cdn.jsdelivr.net/gh/schteppe/cannon.js@0.6.2/build/cannon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
  <!-- animation-mixer por si tienes animaciones -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-animation-mixer@6.0.0/dist/aframe-animation-mixer.min.js"></script>

  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="img/logo.png" type="image/png">

  <style>
    body { margin: 0; font-family: sans-serif; }
    header { z-index: 10000; position: relative; padding: 12px 18px; background:#fff; display:flex; align-items:center; gap:12px; }
    header h1 { margin:0; font-size:18px; color:#111; }
    nav ul { margin:0; padding:0; list-style:none; display:flex; gap:10px; }
    a-scene[embedded] { width: 100%; height: 72vh; display: block; }
    #poema { padding: 20px; max-width: 900px; margin: 18px auto; }
    #ui-debug { position: fixed; right: 18px; top: 18px; z-index:9999; }
    #toggle-colliders { background:#111; color:#fff; border: none; padding:8px 12px; border-radius:6px; cursor:pointer; }
    .debug-collider { opacity: 0.22 !important; }
  </style>
</head>
<body>
  <header>
    <h1>GERARDO ARCOS</h1>
    <nav>
      <ul id="nav-list">
        <li><a href="index.html">Inicio</a></li>
        <li><a href="biografia.html">Sobre Mí</a></li>
        <li><a href="proyectos.html">Proyectos</a></li>
        <li><a href="https://arg3r3v.github.io/axolotl/juego.html">Videojuegos</a></li>
      </ul>
    </nav>
  </header>

  <div id="ui-debug">
    <button id="toggle-colliders">Mostrar colliders (D)</button>
  </div>

  <!-- ESCENA: cuarto con luz interior verde -->
  <a-scene embedded
           physics="gravity: 0 -9.8 0"
           shadow="type: pcfsoft"
           renderer="antialias: true; physicallyCorrectLights: true; colorManagement: true">

    <!-- Assets: 6 secciones -->
    <a-assets>
      <a-asset-item id="cuarto1" src="models/cuarto1.glb"></a-asset-item>
      <a-asset-item id="cuarto2" src="models/cuarto2.glb"></a-asset-item>
      <a-asset-item id="cuarto3" src="models/cuarto3.glb"></a-asset-item>
      <a-asset-item id="cuarto4" src="models/cuarto4.glb"></a-asset-item>
      <a-asset-item id="cuarto5" src="models/cuarto5.glb"></a-asset-item>
      <a-asset-item id="cuarto6" src="models/cuarto6.glb"></a-asset-item>
      <!-- personaje opcional -->
      <a-asset-item id="personajeModel" src="models/personaje.glb"></a-asset-item>
    </a-assets>

    <!-- Ambiente muy tenue -->
    <a-entity light="type: ambient; intensity: 0.06; color: #080808"></a-entity>

    <!-- LUZ INTERIOR VERDE (point + spot) -->
    <!-- Posición cambiada a x:6 y:2 z:4 y ~10x intensidad -->
    <a-entity id="greenLamp"
              light="type: point; color: #2bff7a; intensity: 18; distance: 12; decay: 2"
              position="-6 4 8"></a-entity>

    <a-entity id="greenSpot"
              light="type: spot; color: #2bff7a; intensity: 9; distance: 12; angle: 0.8; penumbra: 0.6; decay: 2"
              position="-6 4 8" rotation="-90 0 0"></a-entity>

    <!-- RIG para movimiento (joystick on mobile + WASD desktop) -->
    <a-entity id="rig"
              position="0 1.6 4"
              kinematic-body
              movement-controls="controls: gamepad, trackpad, keyboard, nipple">
      <a-entity id="cam"
                camera
                look-controls="touchEnabled: true; magicWindowTrackingEnabled: true; pointerLockEnabled: true">
        <a-entity cursor="rayOrigin: mouse" raycaster="objects: .clickable"></a-entity>
      </a-entity>
    </a-entity>

    <!-- MODELOS: 6 secciones (visual only). Colliders se crean automáticamente desde JS -->
    <a-entity id="sec1" gltf-model="#cuarto1" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec2" gltf-model="#cuarto2" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec3" gltf-model="#cuarto3" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec4" gltf-model="#cuarto4" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec5" gltf-model="#cuarto5" position="0 0 0" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="sec6" gltf-model="#cuarto6" position="0 0 0" shadow="cast: true; receive: true"></a-entity>

    <!-- Personaje decorativo (opcional) -->
    <a-entity id="personaje" gltf-model="#personajeModel" position="1 0 -2" scale="1 1 1" animation-mixer="clip: *; loop: repeat" shadow="cast: true"></a-entity>

  </a-scene>

  <!-- Contenido HTML fuera de la escena -->
  <div id="poema">
    <h2>PORQUE AÚN SOY JOVEN</h2>
    <p class="poem">
      Porque aún soy joven, y algo necio,<br>
      Aún soy joven para errar sin malicia,<br>
      Para amar con verdad y sin prisa,<br>
      Para aprender lo que el tiempo avisa,<br>
      Y perderme en charlas de risa,<br>
      En conversaciones sin juicio.
    </p>
  </div>

  <!-- Script: genera colliders invisibles (a-box static-body) a partir del bounding box de cada sección -->
<script>
(function(){
  // Ejecutar cuando la escena esté cargada
  function waitForSceneReady(cb) {
    const scene = document.querySelector('a-scene');
    if (!scene) { console.warn('No a-scene en DOM'); return; }
    if (scene.hasLoaded) return cb(scene);
    scene.addEventListener('loaded', () => cb(scene), { once: true });
  }

  waitForSceneReady(sceneEl => {
    // Config
    const SHADOW_MAP_SIZE = 2048;
    const SHADOW_BIAS = 0.0005; // pequeño positivo
    const LIGHT_DISTANCE = 20;
    const SPOT_ANGLE = 1.0;
    const FORCE_DOUBLE_SIDE = true;
    const COLLIDER_CLASS = 'auto-collider';
    const DEBUG_COLLIDER_CLASS = 'debug-collider';

    // referencias
    const greenPointEl = document.getElementById('greenLamp');
    const greenSpotEl  = document.getElementById('greenSpot');
    const rig = document.getElementById('rig');
    const toggleBtn = document.getElementById('toggle-colliders');

    // --- Utilidades ---
    function safeGetThree() { return window.THREE; }
    const THREE = safeGetThree();

    function applyRendererSettings() {
      if (!sceneEl.renderer) return;
      sceneEl.renderer.shadowMap.enabled = true;
      sceneEl.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      sceneEl.renderer.outputEncoding = THREE.sRGBEncoding;
    }

    function setLightParams(el, opts = {}) {
      if (!el) return;
      el.addEventListener('model-loaded', ()=>{}); // noop to ensure exists
      setTimeout(()=>{ // small tick for three to create light
        const lightObj = el.getObject3D && el.getObject3D('light');
        if (!lightObj) { console.warn('No light object para', el && el.id); return; }
        lightObj.castShadow = true;
        if (lightObj.shadow) {
          lightObj.shadow.mapSize.width = SHADOW_MAP_SIZE;
          lightObj.shadow.mapSize.height = SHADOW_MAP_SIZE;
          lightObj.shadow.bias = SHADOW_BIAS;
          if (lightObj.shadow.camera) {
            lightObj.shadow.camera.near = 0.1;
            lightObj.shadow.camera.far = 100;
            if (lightObj.shadow.camera.updateProjectionMatrix) lightObj.shadow.camera.updateProjectionMatrix();
          }
        }
        if ('distance' in lightObj) lightObj.distance = opts.distance || LIGHT_DISTANCE;
        if (lightObj.isSpotLight) lightObj.angle = opts.spotAngle || SPOT_ANGLE;
        // log
        console.log('Light params applied to', el.id, '->', { distance: lightObj.distance, angle: lightObj.angle });
      }, 200);
    }

    // convierte materiales unlit -> PBR conservando mapas básicos
    function makeMaterialPBR(oldMat) {
      if (!oldMat) return null;
      if (oldMat.isMeshStandardMaterial) { oldMat.needsUpdate = true; return oldMat; }
      const params = {};
      ['map','normalMap','roughnessMap','metalnessMap','aoMap','emissiveMap'].forEach(k => { if (oldMat[k]) params[k] = oldMat[k]; });
      if (oldMat.color) params.color = oldMat.color.clone();
      params.roughness = (typeof oldMat.roughness !== 'undefined') ? oldMat.roughness : 1.0;
      params.metalness = (typeof oldMat.metalness !== 'undefined') ? oldMat.metalness : 0.0;
      const newMat = new THREE.MeshStandardMaterial(params);
      if (FORCE_DOUBLE_SIDE) newMat.side = THREE.DoubleSide;
      newMat.needsUpdate = true;
      return newMat;
    }

    // --- Center camera / rig to scene bounding box center ---
    function centerRigInScene() {
      // compute bounding box for whole scene content (ignora cámara/luces)
      const root = sceneEl.object3D;
      const bbox = new THREE.Box3().setFromObject(root);
      if (!bbox || !bbox.isEmpty()) {
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        const size = new THREE.Vector3();
        bbox.getSize(size);
        // Decide la Y: centro vertical exacto
        const cx = center.x, cy = center.y, cz = center.z;
        // Si quieres la cámara exactamente en el centro del cuarto (no cambiar movimiento),
        // movemos el rig a la posición centro pero mantenemos la orientación y componentes de movimiento.
        // NOTA: movement-controls espera que la posición inicial del rig sea la "posición del jugador".
        if (rig) {
          // preserve original x/z offsets? We'll set rig to center x,z and center y
          rig.setAttribute('position', `${cx} ${cy} ${cz}`);
          console.log('Rig reubicado al centro del bounding box:', { cx, cy, cz, size });
        } else {
          console.warn('No se encontró rig para centrar');
        }
      } else {
        console.warn('Bounding box vacío; no se puede centrar camara');
      }
    }

    // --- Crear colliders a partir de los meshes principales ---
    function createCollidersForModels() {
      // Remove previous auto colliders
      const prev = sceneEl.querySelectorAll('.' + COLLIDER_CLASS);
      prev.forEach(e => e.parentNode && e.parentNode.removeChild(e));

      // recorrer cada entidad gltf-model y crear un a-box que cubra su bounding box
      const modelEntities = sceneEl.querySelectorAll('[gltf-model]');
      modelEntities.forEach(ent => {
        const obj = ent.getObject3D('mesh') || ent.getObject3D('gltf');
        if (!obj) {
          // fallback: esperar al evento model-loaded
          ent.addEventListener('model-loaded', () => { createColliderForEntity(ent); }, { once: true });
        } else {
          createColliderForEntity(ent);
        }
      });
    }

    function createColliderForEntity(ent) {
      const threeObj = ent.getObject3D('mesh') || ent.getObject3D('gltf') || ent.object3D;
      if (!threeObj) { console.warn('No three object para', ent.id); return; }
      // computar bbox local en world space
      const box = new THREE.Box3().setFromObject(threeObj);
      if (box.isEmpty()) { console.warn('BBox vacío para', ent.id); return; }
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      // crear a-box
      const aBox = document.createElement('a-box');
      aBox.classList.add(COLLIDER_CLASS);
      aBox.classList.add(DEBUG_COLLIDER_CLASS); // visible con opacidad CSS
      // convertimos a numeros (a-box usa escala = 1 para 1 unidad)
      aBox.setAttribute('position', `${center.x} ${center.y} ${center.z}`);
      aBox.setAttribute('width', size.x);
      aBox.setAttribute('height', size.y);
      aBox.setAttribute('depth', size.z);
      // physics: static body para que choque con kinematic/dynamic del jugador
      aBox.setAttribute('static-body', 'shape: box;');
      aBox.setAttribute('visible', 'true'); // para debug, invisible por CSS si no quieres
      aBox.style.pointerEvents = 'none';
      // añadir al scene
      sceneEl.appendChild(aBox);
      console.log('Collider creado para', ent.id, 'pos/size:', center, size);
    }

    // Toggle colliders visibility
    function setupToggleUI() {
      if (!toggleBtn) return;
      let shown = true;
      const update = () => {
        const items = sceneEl.querySelectorAll('.' + COLLIDER_CLASS);
        items.forEach(i => {
          // control por clase debug: si quieres invisible quitar DEBUG_COLLIDER_CLASS o CSS
          if (shown) i.classList.add(DEBUG_COLLIDER_CLASS);
          else i.classList.remove(DEBUG_COLLIDER_CLASS);
        });
        toggleBtn.textContent = shown ? 'Ocultar colliders (D)' : 'Mostrar colliders (D)';
      };
      toggleBtn.addEventListener('click', () => { shown = !shown; update(); });
      window.addEventListener('keydown', (ev)=> { if (ev.key.toLowerCase()==='d') { shown = !shown; update(); } });
      update();
    }

    // --- Más robust: asegurarnos que todos los meshes reciban/casten sombras ---
    function forceCastReceiveOnce() {
      sceneEl.object3D.traverse(node => {
        if (node.isMesh) {
          // si no tiene receiveShadow definido, poner true salvo que sea muy fino
          if (typeof node.receiveShadow === 'undefined') node.receiveShadow = true;
          node.castShadow = true;
          // convertir materiales basic->standard si es necesario
          if (node.material && node.material.isMeshBasicMaterial) {
            const newMat = makeMaterialPBR(node.material);
            if (newMat) node.material = newMat;
          }
        }
      });
      console.log('Cast/receive aplicado a meshes.');
    }

    // --- Aplicar: renderer, luces, esperar carga completa de modelos, luego centrar y crear colliders ---
    try {
      applyRendererSettings();

      // 1) colocalas luces donde dijiste: Blender -6,2,4
      if (greenPointEl) greenPointEl.setAttribute('position','-6 2 4');
      if (greenSpotEl)  greenSpotEl.setAttribute('position','-6 2 4');

      // Si quieres valores de intensidad iniciales sugeridos (ajusta visualmente):
      if (greenPointEl) greenPointEl.setAttribute('light', 'type: point; color: #2bff7a; intensity: 800; distance: 10; decay: 2');
      if (greenSpotEl)  greenSpotEl.setAttribute('light', 'type: spot;  color: #2bff7a; intensity: 400; distance: 12; angle: 0.9; penumbra: 0.6; decay: 2');

      setLightParams(greenPointEl, { distance: 20 });
      setLightParams(greenSpotEl, { distance: 20, spotAngle: 0.9 });

      // 2) cuando TODOS los modelos hayan sido cargados (espera model-loaded en cada entidad)
      const modelEntities = Array.from(sceneEl.querySelectorAll('[gltf-model]'));
      let remaining = modelEntities.length;
      if (remaining === 0) {
        // nada que esperar: aplica de una vez
        centerRigInScene();
        forceCastReceiveOnce();
        createCollidersForModels();
        setupToggleUI();
      } else {
        modelEntities.forEach(ent => {
          // si ya cargado
          if (ent.getObject3D('mesh') || ent.getObject3D('gltf')) {
            remaining--;
          } else {
            ent.addEventListener('model-loaded', () => { remaining--; 
              // tiny delay si quieres asegurar texturas
              if (remaining<=0) {
                setTimeout(()=> {
                  centerRigInScene();
                  forceCastReceiveOnce();
                  createCollidersForModels();
                  setupToggleUI();
                }, 120);
              }
            }, { once: true });
          }
        });
        // si todos estaban ya listos
        if (remaining<=0) {
          setTimeout(()=> {
            centerRigInScene();
            forceCastReceiveOnce();
            createCollidersForModels();
            setupToggleUI();
          }, 120);
        }
      }

      console.log('Script mejorado: listo. Revisa consola para detalles.');
    } catch (e) {
      console.error('Error en script mejorado:', e);
    }
  });
})();
</script>

  <script defer src="script.js"></script>
</body>
</html>
