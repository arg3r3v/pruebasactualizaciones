<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>A-Frame escena (v1.6.0) - Movimiento suavizado y sombras mejoradas</title>
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    a-scene { width: 100%; height: 100vh; display: block; }
  </style>
</head>
<body>
  <a-scene id="scene" background="color: #000" renderer="colorManagement: true" embedded>

    <!-- Assets (rutas EXACTAS solicitadas) -->
    <a-assets timeout="0">
      <a-asset-item id="techo"   src="models/techo.glb"></a-asset-item>
      <a-asset-item id="piso"    src="models/piso.glb"></a-asset-item>
      <a-asset-item id="paredes" src="models/paredes.glb"></a-asset-item>

      <a-asset-item id="assets1" src="models/assets1.glb"></a-asset-item>
      <a-asset-item id="assets2" src="models/assets2.glb"></a-asset-item>
      <a-asset-item id="assets3" src="models/assets3.glb"></a-asset-item>
      <a-asset-item id="assets4" src="models/assets4.glb"></a-asset-item>
      <a-asset-item id="assets5" src="models/assets5.glb"></a-asset-item>
      <a-asset-item id="assets6" src="models/assets6.glb"></a-asset-item>
      <a-asset-item id="assets7" src="models/assets7.glb"></a-asset-item>
    </a-assets>

    <!-- Luz puntual verde en el centro (NO mover posición/atributos básicos) -->
    <a-entity id="greenLamp"
              position="0 1 0"
              light="type: point; color: #2bff7a; intensity: 1.6; distance: 12; decay: 2; castShadow: true">
    </a-entity>

    <!-- Luz de relleno hemisférica para bajar contraste y percibir menos ruido -->
    <a-entity light="type: hemisphere; color: #ffffff; groundColor: #222222; intensity: 0.35"></a-entity>

    <!-- Rig + Cámara -->
    <!-- La posición seguirá siendo calculada dinámicamente por el script para centrar la cámara en el cuarto -->
    <a-entity id="rig" position="1.5 1.6 1.5" smooth-walk>
      <a-camera id="camera" position="0 0 0" look-controls="pointerLockEnabled: false; touchEnabled: true"></a-camera>
    </a-entity>

    <!-- Modelos GLB (cada uno en su propia entidad, sin tocar transformaciones internas) -->
    <a-entity id="techo-entity"    gltf-model="#techo"    shadow="cast: true; receive: true"></a-entity>
    <a-entity id="piso-entity"     gltf-model="#piso"     shadow="cast: true; receive: true"></a-entity>
    <a-entity id="paredes-entity"  gltf-model="#paredes"  shadow="cast: true; receive: true"></a-entity>

    <a-entity id="asset1-entity" gltf-model="#assets1" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset2-entity" gltf-model="#assets2" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset3-entity" gltf-model="#assets3" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset4-entity" gltf-model="#assets4" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset5-entity" gltf-model="#assets5" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset6-entity" gltf-model="#assets6" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset7-entity" gltf-model="#assets7" shadow="cast: true; receive: true"></a-entity>

    <!-- Receptor de sombras: plano invisible que cubre el piso del cuarto (se ajusta automáticamente) -->
    <a-plane id="shadow-receiver"
             rotation="-90 0 0"
             position="1.5 0 1.5"
             width="3" height="3"
             material="color:#000; opacity:0; transparent:true">
    </a-plane>

    <!-- Componente smooth-walk y lógica de sombras / centrado -->
    <script>
      AFRAME.registerComponent('smooth-walk', {
        schema: {
          speed: { type: 'number', default: 0.45 },       // m/s (reducido para menos desplazamiento)
          acceleration: { type: 'number', default: 8 },   // para respuesta al cambiar velocidad
          smoothing: { type: 'number', default: 0.12 },   // factor de lerp (más alto = más suave)
          touchSpeed: { type: 'number', default: 0.25 }   // velocidad al tocar pantalla (móvil)
        },
        init: function () {
          this.velocity = new THREE.Vector3();
          this.desired = new THREE.Vector3();
          this.keys = { forward: 0, backward: 0, left: 0, right: 0 };
          this.touchForward = false;
          this.prevTime = performance.now();
          const el = this.el;

          // Listeners teclado
          this.onKeyDown = (e) => {
            switch (e.code) {
              case 'KeyW': case 'ArrowUp': this.keys.forward = 1; break;
              case 'KeyS': case 'ArrowDown': this.keys.backward = 1; break;
              case 'KeyA': case 'ArrowLeft': this.keys.left = 1; break;
              case 'KeyD': case 'ArrowRight': this.keys.right = 1; break;
            }
          };
          this.onKeyUp = (e) => {
            switch (e.code) {
              case 'KeyW': case 'ArrowUp': this.keys.forward = 0; break;
              case 'KeyS': case 'ArrowDown': this.keys.backward = 0; break;
              case 'KeyA': case 'ArrowLeft': this.keys.left = 0; break;
              case 'KeyD': case 'ArrowRight': this.keys.right = 0; break;
            }
          };
          window.addEventListener('keydown', this.onKeyDown);
          window.addEventListener('keyup', this.onKeyUp);

          // Touch simple: tocar pantalla = avanzar (útil en móvil)
          this.onTouchStart = (e) => { this.touchForward = true; };
          this.onTouchEnd = (e) => { this.touchForward = false; };
          window.addEventListener('touchstart', this.onTouchStart, { passive: true });
          window.addEventListener('touchend', this.onTouchEnd);

          // Prevent runaway scale issues: ensure rig scale is 1
          this.el.object3D.scale.set(1,1,1);
        },
        remove: function () {
          window.removeEventListener('keydown', this.onKeyDown);
          window.removeEventListener('keyup', this.onKeyUp);
          window.removeEventListener('touchstart', this.onTouchStart);
          window.removeEventListener('touchend', this.onTouchEnd);
        },
        tick: function (time, delta) {
          const dt = Math.min(delta / 1000, 0.05); // limitar dt para estabilidad
          const data = this.data;
          const camEl = this.el.querySelector('[camera]') || this.el.sceneEl.camera && this.el.sceneEl.camera.el;
          // Obtener forward/right basados en la cámara (mirando horizontalmente)
          let forward = new THREE.Vector3();
          if (camEl && camEl.object3D) {
            camEl.object3D.getWorldDirection(forward);
          } else {
            this.el.object3D.getWorldDirection(forward);
          }
          forward.y = 0;
          forward.normalize();
          const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

          // Determinar input
          const moveZ = (this.keys.forward - this.keys.backward) + (this.touchForward ? 1 : 0);
          const moveX = (this.keys.right - this.keys.left);

          // Desired velocity in world-space (XZ plane)
          this.desired.set(0,0,0);
          if (Math.abs(moveZ) > 0 || Math.abs(moveX) > 0) {
            // combine vectors
            this.desired.add(forward.clone().multiplyScalar(moveZ));
            this.desired.add(right.clone().multiplyScalar(moveX));
            this.desired.normalize();
            // if touch forward, use touchSpeed
            const effectiveSpeed = this.touchForward ? data.touchSpeed : data.speed;
            this.desired.multiplyScalar(effectiveSpeed);
          } else {
            // no input => target zero
            this.desired.set(0,0,0);
          }

          // Smoothly interpolate velocity towards desired
          // factor depends on smoothing and dt (bigger smoothing => faster lerp per frame)
          const lerpFactor = 1 - Math.exp(- (data.smoothing * 30) * dt); // smoother/time-dependent
          this.velocity.lerp(this.desired, lerpFactor);

          // Apply displacement relative to world axes
          const displacement = this.velocity.clone().multiplyScalar(dt);
          this.el.object3D.position.add(displacement);
        }
      });

      (function () {
        const sceneEl = document.getElementById('scene');
        const rigEl = document.getElementById('rig');
        const cameraEl = document.getElementById('camera');
        const shadowReceiverEl = document.getElementById('shadow-receiver');

        const mainIds = ['paredes-entity', 'piso-entity', 'techo-entity'];
        const loaded = {};
        mainIds.forEach(id => loaded[id] = null);

        function isMobile() {
          try {
            return (window.matchMedia && window.matchMedia('(pointer: coarse)').matches)
                   || 'ontouchstart' in window
                   || navigator.maxTouchPoints > 0;
          } catch (e) { return false; }
        }

        function extractObjectFromEvent(el, evt) {
          if (evt && evt.detail && evt.detail.model) {
            const m = evt.detail.model;
            return m.scene || m;
          }
          return el.getObject3D('mesh') || el.getObject3D('gltf') || el.object3D;
        }

        // Center camera when main models loaded (same logic que antes)
        function tryCenterCamera() {
          const objs = Object.values(loaded).filter(Boolean);
          if (objs.length < mainIds.length) return;

          const box = new THREE.Box3();
          objs.forEach(obj => {
            try { box.expandByObject(obj); } catch (e) {}
          });

          if (box.isEmpty()) {
            rigEl.setAttribute('position', '1.5 1.6 1.5');
            cameraEl.setAttribute('position','0 0 0');
            return;
          }

          const center = new THREE.Vector3();
          box.getCenter(center);
          const baseY = box.min.y;
          const cameraHeight = 1.6;
          const rigPos = { x: center.x, y: baseY + cameraHeight, z: center.z };

          rigEl.object3D.position.set(rigPos.x, rigPos.y, rigPos.z);
          cameraEl.setAttribute('position', '0 0 0');

          // Ajustar plano receptor
          const size = new THREE.Vector3();
          box.getSize(size);
          const planeWidth = Math.max(0.01, size.x);
          const planeHeight = Math.max(0.01, size.z);
          shadowReceiverEl.setAttribute('position', `${center.x} ${baseY + 0.001} ${center.z}`);
          shadowReceiverEl.setAttribute('width', planeWidth);
          shadowReceiverEl.setAttribute('height', planeHeight);

          console.log('Rig centrado en:', rigPos);
        }

        mainIds.forEach(id => {
          const el = document.getElementById(id);
          if (!el) { loaded[id] = null; return; }
          el.addEventListener('model-loaded', function (evt) {
            loaded[id] = extractObjectFromEvent(el, evt);
            // ensure its meshes receive/cast shadows
            if (loaded[id]) {
              loaded[id].traverse(node => {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                  if (node.material && node.material.map) {
                    try { node.material.map.encoding = THREE.sRGBEncoding; node.material.needsUpdate = true; } catch(e){}
                  }
                }
              });
            }
            tryCenterCamera();
          }, { once: true });
        });

        // Also ensure every asset entity sets cast/receive on model-loaded
        const allAssetIds = [
          'techo-entity','piso-entity','paredes-entity',
          'asset1-entity','asset2-entity','asset3-entity','asset4-entity','asset5-entity','asset6-entity','asset7-entity'
        ];
        allAssetIds.forEach(id => {
          const el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('model-loaded', function (evt) {
            const obj = extractObjectFromEvent(el, evt);
            if (!obj) return;
            obj.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                if (node.material && node.material.map) {
                  try { node.material.map.encoding = THREE.sRGBEncoding; node.material.needsUpdate = true; } catch(e){}
                }
              }
            });
          });
        });

        // Renderer + shadow tuning
        sceneEl.addEventListener('render-target-loaded', function () {
          const renderer = sceneEl.renderer;
          if (!renderer) { console.warn('Renderer no disponible'); return; }

          // Shadow & color management
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          renderer.outputEncoding = THREE.sRGBEncoding;
          renderer.physicallyCorrectLights = true;
          // PixelRatio reducido para estabilidad y menos jitter (ruido)
          renderer.setPixelRatio(1);

          // Tone mapping estabilizador (opcional)
          try {
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
          } catch (e) {}

          // Ajustar greenLamp shadows internamente (sin mover la luz)
          const greenLampEl = document.getElementById('greenLamp');
          const lightObj = greenLampEl && greenLampEl.getObject3D ? greenLampEl.getObject3D('light') : null;

          if (lightObj && lightObj.shadow) {
            try {
              lightObj.castShadow = true;
              // Elegimos 2048 como tope por compatibilidad GPU; en mobile usar 1024
              const mobile = isMobile();
              const chosen = mobile ? 1024 : 2048;
              if (lightObj.shadow.mapSize && typeof lightObj.shadow.mapSize.set === 'function') {
                lightObj.shadow.mapSize.set(chosen, chosen);
              }
              // Suavizado mayor para PCF
              if (typeof lightObj.shadow.radius !== 'undefined') {
                lightObj.shadow.radius = 12;
              }
              // Bias ajustado para reducir acne; negativo pequeño
              if (typeof lightObj.shadow.bias !== 'undefined') {
                lightObj.shadow.bias = -0.0008;
              }
              if (lightObj.shadow) lightObj.shadow.needsUpdate = true;
              console.log('GreenLamp shadow configured: size=', chosen, 'radius=', lightObj.shadow.radius, 'bias=', lightObj.shadow.bias);
            } catch (err) {
              console.warn('No se pudo configurar completamente greenLamp.shadow', err);
            }
          } else {
            console.warn('No se encontró greenLamp.light para configurar sombras');
          }

          // Asegurar que el receptor de sombras reciba
          const planeObj = shadowReceiverEl.getObject3D('mesh') || shadowReceiverEl.object3D;
          if (planeObj) {
            planeObj.traverse(node => {
              if (node.isMesh) {
                node.receiveShadow = true;
                node.castShadow = false;
                if (node.material) {
                  node.material.transparent = true;
                  node.material.opacity = 0;
                  node.material.needsUpdate = true;
                }
              }
            });
          }

          console.log('Renderer configurado. shadowMap.enabled=', renderer.shadowMap.enabled, 'type=', renderer.shadowMap.type);
        });

        // Fallback: forzar centrado si model-loaded no ocurre por timeout
        setTimeout(tryCenterCamera, 6000);
      })();
    </script>

  </a-scene>
</body>
</html>
