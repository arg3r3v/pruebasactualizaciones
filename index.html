<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Galería — Cuartos (shadows + 1 luz interior)</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

  <style>
    body { margin: 0; }
  </style>
</head>
<body>
  <!-- ESCENA -->
  <a-scene id="scene"
           renderer="antialias: true; physicallyCorrectLights: true"
           shadow="type: pcfsoft; autoUpdate: true"
           background="color: #bfcdd8">

    <!-- ASSETS: solo los 6 archivos glb que pediste -->
    <a-assets>
      <a-asset-item id="cuarto1" src="models/cuarto1.glb"></a-asset-item>
      <a-asset-item id="cuarto2" src="models/cuarto2.glb"></a-asset-item>
      <a-asset-item id="cuarto3" src="models/cuarto3.glb"></a-asset-item>
      <a-asset-item id="cuarto4" src="models/cuarto4.glb"></a-asset-item>
      <a-asset-item id="cuarto5" src="models/cuarto5.glb"></a-asset-item>
      <a-asset-item id="cuarto6" src="models/cuarto6.glb"></a-asset-item>
    </a-assets>

    <!-- Nota: Uso #cuarto1 como navmesh por defecto. Si tienes un glb de navmesh distinto, cámbialo. -->
    <!-- LUZ ÚNICA (dentro del cuarto): SpotLight para sombras fuertes y realistas interiores -->
    <a-entity id="lamp"
              position="0 3 0"
              rotation="0 0 0"
              light="type: spot;
                     color: #fff;
                     intensity: 1.2;
                     distance: 30;
                     angle: 0.9;
                     penumbra: 0.8;
                     decay: 2;
                     castShadow: true"
              shadow="mapSizeWidth: 2048; mapSizeHeight: 2048; bias: -0.0006; radius: 1.5">
      <!-- Un pequeño "objeto visual" opcional para ubicar la lámpara (puedes quitarlo) -->
      <a-sphere radius="0.08" position="0 0 0" visible="false"></a-sphere>
    </a-entity>

    <!-- RIG y cámara — manteniendo la lógica de movimiento y colisiones -->
    <a-entity id="rig" position="0 0 2"
              movement-controls="constrainToNavMesh: true; controls: checkpoint, gamepad, trackpad, keyboard, nipple;">
      <a-entity camera position="0 1.8 0" look-controls="pointerLockEnabled: true">
        <a-cursor></a-cursor>
      </a-entity>
    </a-entity>

    <!-- Navmesh: aquí uso el glb cuarto1 como referencia (ajusta si es necesario) -->
    <a-entity id="navmesh" visible="false" gltf-model="#cuarto1"></a-entity>

    <!-- Inserta los 6 gltf como entidades en la escena (posiciones de ejemplo; ajusta a tu layout) -->
    <!-- Asumo que cuarto1 es el recinto principal (con paredes/techo/piso). -->
    <a-entity id="room" gltf-model="#cuarto1" position="0 0 0" rotation="0 0 0" scale="1 1 1"></a-entity>

    <!-- Los otros cuartos/assets (puedes posicionarlos dentro del espacio según necesites) -->
    <a-entity id="asset2" gltf-model="#cuarto2" position="2 0 -2" rotation="0 0 0" scale="1 1 1"></a-entity>
    <a-entity id="asset3" gltf-model="#cuarto3" position="-2 0 -2" rotation="0 0 0" scale="1 1 1"></a-entity>
    <a-entity id="asset4" gltf-model="#cuarto4" position="2 0 2" rotation="0 0 0" scale="1 1 1"></a-entity>
    <a-entity id="asset5" gltf-model="#cuarto5" position="-2 0 2" rotation="0 0 0" scale="1 1 1"></a-entity>
    <a-entity id="asset6" gltf-model="#cuarto6" position="0 0 4" rotation="0 0 0" scale="1 1 1"></a-entity>

    <!-- SCRIPT: activa shadowMap y habilita cast/receive automáticamente en modelos -->
    <script>
      AFRAME.registerSystem('shadows-setup', {
        init: function () {
          const sceneEl = this.el;
          // Aseguramos el renderer y shadowMap
          sceneEl.addEventListener('render-target-loaded', () => {
            try {
              if (sceneEl.renderer) {
                sceneEl.renderer.shadowMap.enabled = true;
                sceneEl.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                // physLights ya está en renderer attribute; reforzamos
                if (sceneEl.renderer.physicallyCorrectLights !== true) {
                  sceneEl.renderer.physicallyCorrectLights = true;
                }
              }
            } catch (e) { console.warn('No se pudo configurar renderer.shadowMap:', e); }
          });

          // Función que activa cast/receive en un elemento cuando su modelo carga
          function enableShadowsForEntity(el) {
            // marcar atributo shadow para que A-Frame lo sepa también
            el.setAttribute && el.setAttribute('shadow', 'cast: true; receive: true');

            el.addEventListener('model-loaded', function (evt) {
              // algunos modelos exponen 'mesh' o 'model'
              const obj = el.getObject3D('mesh') || el.getObject3D('model');
              if (!obj) return;
              obj.traverse(function (node) {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                  if (node.material) node.material.needsUpdate = true;
                }
              });
            });

            // Si ya está cargado
            const maybeObj = el.getObject3D('mesh') || el.getObject3D('model');
            if (maybeObj) {
              maybeObj.traverse(function (node) {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                }
              });
            }
          }

          // Aplicar a todos los gltf-model presentes
          const nodes = sceneEl.querySelectorAll('[gltf-model]');
          nodes.forEach(enableShadowsForEntity);

          // Observar nuevos nodos añadidos dinámicamente
          const mo = new MutationObserver((mutations) => {
            mutations.forEach(m => {
              m.addedNodes.forEach(node => {
                if (!(node instanceof Element)) return;
                if (node.hasAttribute && node.hasAttribute('gltf-model')) {
                  enableShadowsForEntity(node);
                }
              });
            });
          });
          mo.observe(sceneEl, { childList: true, subtree: true });
        }
      });
    </script>

  </a-scene>
</body>
</html>
