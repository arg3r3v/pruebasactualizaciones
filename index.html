<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Galería — Diagnóstico y correcciones (posiciones actualizadas)</title>

  <script crossorigin="anonymous" src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>

  <style>
    html,body{height:100%;margin:0;background:#000}
    a-scene{height:100vh;width:100vw}
    #af-debug { position:fixed; right:8px; bottom:8px; font:12px/1.2 monospace; color:#0f0; background: rgba(0,0,0,0.35); padding:8px; border-radius:6px; z-index:9999; max-width:320px; display:none; }
  </style>
</head>
<body>
  <a-scene id="scene"
           background="color:#000000"
           renderer="antialias:true; physicallyCorrectLights:true; colorManagement:true">
    <a-assets>
      <a-asset-item id="cuarto1" src="models/cuarto1.glb"></a-asset-item>
      <a-asset-item id="cuarto2" src="models/cuarto2.glb"></a-asset-item>
      <a-asset-item id="cuarto3" src="models/cuarto3.glb"></a-asset-item>
      <a-asset-item id="cuarto4" src="models/cuarto4.glb"></a-asset-item>
      <a-asset-item id="cuarto5" src="models/cuarto5.glb"></a-asset-item>
      <a-asset-item id="cuarto6" src="models/cuarto6.glb"></a-asset-item>
    </a-assets>

    <!-- Ambient suave -->
    <a-entity light="type:ambient; intensity:0.14; color:#0b0b0b"></a-entity>

    <!-- Escenario y props (sin cambiar posiciones/intensidades) -->
    <a-entity id="cuarto1_ent" gltf-model="#cuarto1" nav-mesh shadow="receive:true"></a-entity>
    <a-entity id="cuarto2_ent" gltf-model="#cuarto2" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="cuarto3_ent" gltf-model="#cuarto3" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="cuarto4_ent" gltf-model="#cuarto4" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="cuarto5_ent" gltf-model="#cuarto5" shadow="cast:true; receive:true"></a-entity>
    <a-entity id="cuarto6_ent" gltf-model="#cuarto6" shadow="cast:true; receive:true"></a-entity>

    <!-- LUZ: mantengo tu luz, sin tocar posición/intensidad -->
    <a-entity id="greenLamp" position="0 2.88 0"
              light="type:point; color: #2bff7a; intensity: 144; distance: 30; decay: 2; castShadow: true">
    </a-entity>

    <!-- RIG / Cámara: mantengo la cámara tal como pediste -->
    <a-entity id="rig" position="0 0 2"
              movement-controls="constrainToNavMesh: true; controls: checkpoint,gamepad,trackpad,keyboard,nipple;">
      <a-entity camera position="0 4.05 0" look-controls="pointerLockEnabled:true"><a-cursor></a-cursor></a-entity>
    </a-entity>
  </a-scene>

  <div id="af-debug">debug</div>

<script>
(function(){
  const debugEl = document.getElementById('af-debug');
  function dbg(...args){ try { console.log(...args); if (debugEl) { debugEl.style.display='block'; debugEl.textContent = args.map(a=> (typeof a==='object'? JSON.stringify(a): String(a))).join(' '); } } catch(e){} }

  const THREE = (window.AFRAME && AFRAME.THREE) ? AFRAME.THREE : window.THREE;
  const sceneEl = document.getElementById('scene');
  if (!sceneEl) return;

  const TARGET_MIN_TEX = 1024;
  const MAX_PIXELRATIO = Math.min(window.devicePixelRatio || 1, 2);
  const SHADOW_MAP_SIZE = 2048;
  const SHADOW_BIAS = -0.0004;
  const SHADOW_NORMAL_BIAS = 0.02;

  function isPowerOfTwo(v){ return Number.isInteger(v) && v > 0 && (v & (v - 1)) === 0; }
  function nextPOT(v){ let p=1; while(p<v) p<<=1; return p; }

  // ---------- CORRECCIÓN: encoding por tipo ----------
  // Sólo color/emissive/alpha deben ir en sRGB.
  // AO, lightMap, normalMap, roughnessMap, metalnessMap => LinearEncoding
  function preferSRGBForKey(key){
    return (key === 'map' || key === 'emissiveMap' || key === 'alphaMap');
  }
  // ---------------------------------------------------

  sceneEl.addEventListener('render-target-loaded', () => {
    try {
      const renderer = sceneEl.renderer;
      if (!renderer) return;
      renderer.setPixelRatio(MAX_PIXELRATIO);
      if (THREE && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      if (THREE && THREE.PCFSoftShadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      dbg('[fix] renderer configured; pixelRatio=', renderer.getPixelRatio());
    } catch(e){ console.warn('[fix] renderer config failed', e); }
  });

  function promoteToStandard(oldMat){
    if (!oldMat) return null;
    if (oldMat.isMeshStandardMaterial) return oldMat;
    const newMat = new THREE.MeshStandardMaterial();

    const copyTexKeys = ['map','normalMap','roughnessMap','metalnessMap','aoMap','emissiveMap','alphaMap','lightMap'];
    copyTexKeys.forEach(k => { if (oldMat[k]) newMat[k] = oldMat[k]; });

    const copyFlags = [
      'transparent','opacity','alphaTest','vertexColors','skinning','morphTargets',
      'flatShading','wireframe','emissiveIntensity','name','userData'
    ];
    copyFlags.forEach(k => { if (oldMat[k] !== undefined) newMat[k] = oldMat[k]; });

    newMat.side = (oldMat.side !== undefined) ? oldMat.side : THREE.FrontSide;

    if (oldMat.color) try { newMat.color.copy(oldMat.color); } catch(e){}
    if (oldMat.emissive) try { newMat.emissive.copy(oldMat.emissive); } catch(e){}

    newMat.roughness = (oldMat.roughness !== undefined) ? oldMat.roughness : (newMat.roughness !== undefined ? newMat.roughness : 1.0);
    newMat.metalness = (oldMat.metalness !== undefined) ? oldMat.metalness : (newMat.metalness !== undefined ? newMat.metalness : 0.0);

    newMat.needsUpdate = true;
    return newMat;
  }

  function ensureTextureGood(tex, key, renderer, mesh){
    if (!tex) return {ok:false, reason:'no-tex'};
    const img = tex.image;
    if (!img) return {ok:false, reason:'no-image'};
    const w = img.width || img.naturalWidth || img.bitmapWidth || 0;
    const h = img.height || img.naturalHeight || img.bitmapHeight || 0;
    const isPOT = isPowerOfTwo(w) && isPowerOfTwo(h);

    try { tex.encoding = preferSRGBForKey(key) && THREE && THREE.sRGBEncoding ? THREE.sRGBEncoding : THREE.LinearEncoding; } catch(e){}

    if ((key === 'aoMap' || key === 'lightMap') && mesh && mesh.geometry && !mesh.geometry.attributes.uv2) {
      return {ok:false, reason:'missing-uv2'};
    }

    if (!isPOT || Math.max(w,h) < TARGET_MIN_TEX) {
      try {
        const maxTex = renderer.capabilities && (renderer.capabilities.maxTextureSize || 4096) || 4096;
        const desired = Math.min(maxTex, Math.max(TARGET_MIN_TEX, Math.max(w,h)));
        const target = nextPOT(desired);
        const canvas = document.createElement('canvas');
        canvas.width = target; canvas.height = target;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        const aspect = (w && h) ? (w/h) : 1;
        let dw = target, dh = target;
        if (aspect > 1) dh = Math.round(target / aspect); else dw = Math.round(target * aspect);
        const ox = Math.round((target-dw)/2), oy = Math.round((target-dh)/2);
        ctx.drawImage(img, ox, oy, dw, dh);

        const newTex = new THREE.CanvasTexture(canvas);
        newTex.generateMipmaps = true;
        newTex.minFilter = THREE.LinearMipmapLinearFilter;
        newTex.magFilter = THREE.LinearFilter;
        try { 
          const maxAniso = renderer.capabilities && (renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1) || 1;
          newTex.anisotropy = maxAniso;
        } catch(e){ newTex.anisotropy = 1; }

        newTex.wrapS = tex.wrapS || THREE.ClampToEdgeWrapping;
        newTex.wrapT = tex.wrapT || THREE.ClampToEdgeWrapping;
        if (tex.flipY !== undefined) newTex.flipY = tex.flipY;
        if (tex.premultiplyAlpha !== undefined) newTex.premultiplyAlpha = tex.premultiplyAlpha;
        if (tex.format !== undefined) newTex.format = tex.format;

        newTex.encoding = preferSRGBForKey(key) && THREE && THREE.sRGBEncoding ? THREE.sRGBEncoding : THREE.LinearEncoding;
        newTex.needsUpdate = true;
        return {ok:true, replaced:true, newTex};
      } catch(e){
        return {ok:false, reason:'canvas-resize-failed', err:e};
      }
    }

    try {
      tex.generateMipmaps = true;
      tex.minFilter = tex.minFilter || THREE.LinearMipmapLinearFilter;
      tex.magFilter = tex.magFilter || THREE.LinearFilter;
      tex.anisotropy = tex.anisotropy || (renderer.capabilities && renderer.capabilities.getMaxAnisotropy && renderer.capabilities.getMaxAnisotropy()) || 1;
      tex.needsUpdate = true;
    } catch(e){}
    return {ok:true, replaced:false, info:{w,h,isPOT}};
  }

  function detectFloorCandidates(root){
    const meshes = [];
    root.traverse(node => { if (node.isMesh) meshes.push(node); });
    if (!meshes.length) return [];
    const byName = meshes.filter(m => m.name && /floor|piso|ground|suelo|tile|wall|ceiling|techo/i.test(m.name));
    if (byName.length) return byName;
    const areaArr = meshes.map(m=>{
      const bb = new THREE.Box3().setFromObject(m);
      const s = new THREE.Vector3(); bb.getSize(s);
      return {m, area: Math.abs(s.x * s.z) || (Math.abs(s.x*s.y) + Math.abs(s.y*s.z) + Math.abs(s.x*s.y)), size:s};
    }).sort((a,b)=>b.area-a.area);
    return areaArr.slice(0,1).map(x=>x.m);
  }

  function inspectAndFixModel(el){
    if (!el) return;
    const renderer = sceneEl.renderer;

    function onModelLoaded(ev){
      try {
        const root = ev.detail && ev.detail.model ? ev.detail.model : (el.getObject3D('mesh') || el.getObject3D('model'));
        if (!root) return;
        const fixes = [];
        dbg('[fix] inspecting', el.id);

        const floorCandidates = detectFloorCandidates(root);
        const floorSet = new Set(floorCandidates);

        root.traverse(node => {
          if (!node.isMesh) return;

          if (node.geometry && !node.geometry.attributes.normal) {
            node.geometry.computeVertexNormals();
            fixes.push({type:'computedNormals', mesh: node.name || node.id});
          }

          let nodeMaterials = Array.isArray(node.material) ? node.material.slice() : [node.material];
          let treatAsRoom = floorSet.has(node);

          if (!treatAsRoom) {
            try {
              const bb = new THREE.Box3().setFromObject(node);
              const s = new THREE.Vector3(); bb.getSize(s);
              const area = Math.abs(s.x * s.z);
              if (area > 1.0) treatAsRoom = true;
            } catch(e){}
          }

          if (treatAsRoom) {
            nodeMaterials = nodeMaterials.map(mat => {
              if (!mat) return mat;
              try { return mat.clone ? mat.clone() : Object.assign(Object.create(Object.getPrototypeOf(mat)), mat); }
              catch(e){ return mat; }
            });
            node.material = Array.isArray(node.material) ? nodeMaterials : nodeMaterials[0];
            fixes.push({type:'clonedMatsForRoom', mesh: node.name || node.id});
            dbg('[fix] cloned materials for', node.name || node.id);
          }

          nodeMaterials.forEach((mat, idx) => {
            if (!mat) return;

            if (mat.isMeshBasicMaterial || mat.isMeshLambertMaterial || mat.isMeshPhongMaterial) {
              const promoted = promoteToStandard(mat);
              if (promoted) {
                if (Array.isArray(node.material)) node.material[idx] = promoted;
                else node.material = promoted;
                mat = promoted;
                fixes.push({type:'promotedMaterial', mesh: node.name || node.id, matIndex: idx});
              }
            }

            ['map','emissiveMap','lightMap','aoMap','normalMap','metalnessMap','roughnessMap','alphaMap'].forEach(k => {
              if (node.material && node.material[k]) {
                const res = ensureTextureGood(node.material[k], k, renderer, node);
                if (res.ok && res.replaced && res.newTex) {
                  try { if (node.material[k] && node.material[k].dispose) node.material[k].dispose(); } catch(e){}
                  node.material[k] = res.newTex;
                  node.material.needsUpdate = true;
                  fixes.push({type:'replacedTexture', mesh: node.name || node.id, key:k, size: `${res.newTex.image.width}x${res.newTex.image.height}`});
                  dbg('[fix] replaced texture', k, 'on', node.name || node.id);
                } else if (!res.ok) {
                  if (res.reason === 'missing-uv2') {
                    node.material[k] = null;
                    node.material.needsUpdate = true;
                    fixes.push({type:'removedMapMissingUV2', mesh: node.name || node.id, key:k});
                    dbg('[fix] removed', k, 'due missing uv2 on', node.name || node.id);
                  } else {
                    fixes.push({type:'texProblem', mesh: node.name || node.id, key:k, reason: res.reason || ''});
                    dbg('[fix] texture problem', node.name || node.id, k, res.reason || '');
                  }
                }
              }
            });

            try {
              if (mat.opacity !== undefined && mat.opacity >= 0.999) {
                if (mat.transparent) { mat.transparent = false; fixes.push({type:'transparentDisabled', mesh: node.name || node.id}); dbg('[fix] transparent disabled'); }
                if (mat.depthWrite === false) { mat.depthWrite = true; fixes.push({type:'depthWriteEnabled', mesh: node.name || node.id}); dbg('[fix] depthWrite enabled'); }
              } else {
                if (mat.transparent) {
                  if (mat.alphaTest === undefined || mat.alphaTest > 0.05) {
                    const old = mat.alphaTest || 0;
                    mat.alphaTest = Math.min(0.05, old || 0.05);
                    fixes.push({type:'alphaTestAdjusted', mesh: node.name || node.id, old, newVal: mat.alphaTest});
                    dbg('[fix] alphaTest adjusted', old, mat.alphaTest);
                  }
                }
              }
            } catch(e){ dbg('[fix] flags error', e); }

            try {
              if (!mat.polygonOffset) {
                mat.polygonOffset = true;
                mat.polygonOffsetFactor = (mat.polygonOffsetFactor !== undefined) ? mat.polygonOffsetFactor : 1;
                mat.polygonOffsetUnits = (mat.polygonOffsetUnits !== undefined) ? mat.polygonOffsetUnits : 4;
                fixes.push({type:'polygonOffsetApplied', mesh: node.name || node.id});
                dbg('[fix] polygonOffset applied on', node.name || node.id);
              }
            } catch(e){ dbg('[fix] polygonOffset error', e); }

            if (treatAsRoom) {
              try {
                mat.side = THREE.DoubleSide;
                if (mat.opacity !== undefined && mat.opacity >= 0.999) {
                  mat.transparent = false;
                  mat.depthWrite = true;
                }
                mat.needsUpdate = true;
                fixes.push({type:'roomMatDoubleSided', mesh: node.name || node.id});
                dbg('[fix] forced DoubleSide on cloned room material', node.name || node.id);
              } catch(e){ dbg('[fix] force double side error', e); }
            }
          });

          if (!(node.userData && node.userData.noShadow)) {
            node.castShadow = true;
            node.receiveShadow = true;
          }
        });

        dbg('[fix] issues found/fixed for', el.id, fixes.length ? fixes : 'none');

        // after per-model fixes, run a defensive scene-wide pass (reapply encodings and fallback)
        applySceneFallbacks();
      } catch(e){
        console.warn('[fix] model inspect failed for', el.id, e);
      }
    }

    el.addEventListener('model-loaded', onModelLoaded, { once: true });

    const maybe = el.getObject3D('mesh') || el.getObject3D('model');
    if (maybe) el.emit('model-loaded', { model: maybe }, false);
  }

  function enhanceLampShadows(lampId){
    const el = document.getElementById(lampId);
    if (!el) return;
    el.addEventListener('object3dset', function handler(){
      const light = el.getObject3D && el.getObject3D('light');
      if (!light) return console.warn('[fix] Light object not found for', lampId);
      light.castShadow = true;
      if (light.shadow) {
        const maxAllowed = (sceneEl.renderer && sceneEl.renderer.capabilities && sceneEl.renderer.capabilities.maxTextureSize) || SHADOW_MAP_SIZE;
        const ms = Math.min(SHADOW_MAP_SIZE, maxAllowed);
        try { if (light.shadow.map) { light.shadow.map.dispose(); light.shadow.map = null; } } catch(e){}
        light.shadow.mapSize.width = ms;
        light.shadow.mapSize.height = ms;
        if ('bias' in light.shadow) light.shadow.bias = SHADOW_BIAS;
        if (light.shadow.normalBias !== undefined) light.shadow.normalBias = SHADOW_NORMAL_BIAS;
        else if (light.normalBias !== undefined) light.normalBias = SHADOW_NORMAL_BIAS;
        if (light.shadow.radius !== undefined) light.shadow.radius = 2.5;
        if (light.shadow.camera && light.shadow.camera.updateProjectionMatrix) {
          light.shadow.camera.near = 0.1;
          light.shadow.camera.far = 200;
          light.shadow.camera.updateProjectionMatrix();
        }
      }
      dbg('[fix] lamp shadow params applied for', lampId);
    }, { once: true });
  }

  // defensive pass: reapply correct encodings globally, ensure visible fallback for large room mesh if needed
  function applySceneFallbacks(){
    try {
      let adjusted = 0;
      // 1) reapply encoding for all material maps
      sceneEl.object3D.traverse(node => {
        if (!node.isMesh) return;
        const mats = Array.isArray(node.material) ? node.material : [node.material];
        mats.forEach(m => {
          if (!m) return;
          ['map','emissiveMap','alphaMap'].forEach(k=>{
            if (m[k] && m[k].encoding !== THREE.sRGBEncoding) {
              try { m[k].encoding = THREE.sRGBEncoding; m[k].needsUpdate = true; adjusted++; dbg('[fallback] set sRGB for', k, 'on', node.name); } catch(e){}
            }
          });
          ['aoMap','lightMap','normalMap','roughnessMap','metalnessMap'].forEach(k=>{
            if (m[k] && m[k].encoding !== THREE.LinearEncoding) {
              try { m[k].encoding = THREE.LinearEncoding; m[k].needsUpdate = true; adjusted++; dbg('[fallback] set Linear for', k, 'on', node.name); } catch(e){}
            }
          });

          // If material has no color map and appears likely to be room material, give visible color fallback
          try {
            const isLarge = (function(){
              const bb = new THREE.Box3().setFromObject(node); const s = new THREE.Vector3(); bb.getSize(s);
              const area = Math.abs(s.x * s.z) || Math.abs(s.x*s.y) || Math.abs(s.y*s.z);
              return area > 0.8;
            })();
            if (isLarge) {
              // If no base color/intended texture, avoid entirely black result — set neutral color
              if (!m.map && m.color && m.color.getHex && m.color.getHex() === 0x000000) {
                m.color.setHex(0x888888);
                m.transparent = false;
                m.depthWrite = true;
                m.needsUpdate = true;
                adjusted++;
                dbg('[fallback] applied neutral color to large mesh material on', node.name || node.id);
              }
              // Also ensure double side if material is cloned (heuristic: userData.clonedRoom true set earlier?)
              // We set DoubleSide only if the material appears unique (usage count == 1)
              if (m.side !== THREE.DoubleSide) {
                // compute usage count
                let usage = 0;
                sceneEl.object3D.traverse(n2 => {
                  if (!n2.isMesh) return;
                  const mlist = Array.isArray(n2.material) ? n2.material : [n2.material];
                  mlist.forEach(mm => { if (mm === m) usage++; });
                });
                if (usage === 1) {
                  m.side = THREE.DoubleSide;
                  m.needsUpdate = true;
                  dbg('[fallback] set DoubleSide for unique large material on', node.name);
                }
              }
            }
          } catch(e){ dbg('[fallback] large-mesh fallback error', e); }
        });
      });

      // 2) Quick diagnostic: if cuarto1_ent exists and its largest mesh has no usable map/color, assign a test material (visible)
      const ent = document.getElementById('cuarto1_ent');
      if (ent) {
        const root = ent.getObject3D('mesh') || ent.getObject3D('model');
        if (root) {
          let best = null, bestA = 0;
          root.traverse(n => {
            if (!n.isMesh) return;
            const bb = new THREE.Box3().setFromObject(n); const s = new THREE.Vector3(); bb.getSize(s);
            const area = Math.abs(s.x * s.z) || Math.abs(s.x*s.y) || Math.abs(s.y*s.z);
            if (area > bestA) { bestA = area; best = n; }
          });
          if (best) {
            // check if best.material has a map or a non-black color
            const mats = Array.isArray(best.material) ? best.material : [best.material];
            let needTest = false;
            mats.forEach(m => {
              if (!m) { needTest = true; return; }
              const hasMap = !!m.map;
              const isBlackColor = (m.color && m.color.getHex && m.color.getHex() === 0x000000);
              if (!hasMap && isBlackColor) needTest = true;
            });
            if (needTest) {
              let baseMap = (mats[0] && mats[0].map) || null;
              let testMat;
              try {
                if (baseMap) testMat = new THREE.MeshStandardMaterial({ map: baseMap, side: THREE.DoubleSide });
                else testMat = new THREE.MeshStandardMaterial({ color: 0x999999, side: THREE.DoubleSide });
                if (Array.isArray(best.material)) best.material = best.material.map(_=> testMat);
                else best.material = testMat;
                best.material.needsUpdate = true;
                dbg('[fallback] test material applied to largest room mesh:', best.name || best.id);
                adjusted++;
              } catch(e){ dbg('[fallback] test material fail', e); }
            }
          }
        }
      }

      if (adjusted) dbg('[fallback] scene fallback adjustments done — count:', adjusted);
    } catch(e){ console.warn('[fallback] applySceneFallbacks error', e); }
  }

  // Ejecutar inspect en todos los gltf-models de la escena
  const nodes = sceneEl.querySelectorAll('[gltf-model]');
  nodes.forEach(n => inspectAndFixModel(n));
  enhanceLampShadows('greenLamp');

  // debug helpers
  window.__aframe_debug = {
    toggleWireframe: function(state){
      sceneEl.object3D.traverse(node=>{
        if (node.isMesh && node.material){
          const mats = Array.isArray(node.material) ? node.material : [node.material];
          mats.forEach(m=>{ if (m){ m.wireframe = (state===undefined) ? !m.wireframe : !!state; m.needsUpdate=true; } });
        }
      });
    },
    onlyAmbient: function(on){
      sceneEl.object3D.traverse(node=>{
        if (node.isLight && node.type !== 'AmbientLight'){
          node.visible = on ? false : true;
        }
      });
      dbg('[debug] onlyAmbient=', !!on);
    },
    listMaterials: function(){
      const out = [];
      sceneEl.object3D.traverse(n => { if (n.isMesh && n.material) out.push({mesh: n.name || n.id, material: n.material}); });
      console.log(out);
      return out;
    },
    forceRoomMaterial: function(){
      const ent = document.getElementById('cuarto1_ent');
      if (!ent) { console.warn('No cuarto1_ent'); return; }
      const root = ent.getObject3D('mesh') || ent.getObject3D('model');
      if (!root) { console.warn('Modelo no listo'); return; }
      let best = null; let bestA = 0;
      root.traverse(n => {
        if (!n.isMesh) return;
        const bb = new THREE.Box3().setFromObject(n); const s = new THREE.Vector3(); bb.getSize(s);
        const area = Math.abs(s.x * s.z) || Math.abs(s.x*s.y) || Math.abs(s.y*s.z);
        if (area > bestA) { bestA = area; best = n; }
      });
      if (!best) { console.warn('No mesh encontrado'); return; }
      console.log('forceRoomMaterial -> mesh:', best.name || best.id, 'area', bestA);

      let testMat;
      try {
        const baseMap = best.material && (Array.isArray(best.material) ? best.material[0].map : best.material.map);
        if (baseMap) {
          testMat = new THREE.MeshStandardMaterial({ map: baseMap, side: THREE.DoubleSide });
          if (Array.isArray(best.material)) best.material = best.material.map(_=> testMat);
          else best.material = testMat;
        } else {
          testMat = new THREE.MeshStandardMaterial({ color: 0x888888, side: THREE.DoubleSide });
          if (Array.isArray(best.material)) best.material = best.material.map(_=> testMat);
          else best.material = testMat;
        }
        best.material.needsUpdate = true;
        best.castShadow = true; best.receiveShadow = true;
      } catch(e){ console.warn('forceRoomMaterial failed', e); }
      console.log('forceRoomMaterial applied; verifica si la geometría aparece (si sí, es problema de mapas o encoding).');
    }
  };

  dbg('[fix] Diagnostics loaded — usa __aframe_debug.* en la consola.');
})();
</script>
</body>
</html>
