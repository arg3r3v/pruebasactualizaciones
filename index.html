<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Cuarto A-Frame — movilidad, sombras y compatibilidad móvil</title>

  <!-- A-Frame 1.6.0 -->
  <script crossorigin="anonymous" src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>

  <style>
    html,body{height:100%;margin:0;background:#000}
    a-scene{height:100vh;width:100vw;display:block}
    /* HUD pequeño opcional para debug (se muestra solo si hay mensajes) */
    #af-debug { position:fixed; right:8px; bottom:8px; font:12px/1.2 monospace; color:#bfffbf; background: rgba(0,0,0,0.45); padding:8px; border-radius:6px; z-index:9999; max-width:320px; display:none; pointer-events:none; }
  </style>
</head>
<body>
  <div id="af-debug">debug</div>

  <a-scene id="scene"
           renderer="antialias:true; physicallyCorrectLights:true; colorManagement:true"
           background="color: #000000"
           vr-mode-ui="enabled: true">

    <!-- ASSETS: (IDs y rutas tal como pediste) -->
    <a-assets>
      <a-asset-item id="techo" src="models/techo.glb"></a-asset-item>
      <a-asset-item id="piso" src="models/piso.glb"></a-asset-item>
      <a-asset-item id="paredes" src="models/paredes.glb"></a-asset-item>
      <a-asset-item id="assets1" src="models/assets1.glb"></a-asset-item>
      <a-asset-item id="assets2" src="models/assets2.glb"></a-asset-item>
      <a-asset-item id="assets3" src="models/assets3.glb"></a-asset-item>
      <a-asset-item id="assets4" src="models/assets4.glb"></a-asset-item>
      <a-asset-item id="assets5" src="models/assets5.glb"></a-asset-item>
      <a-asset-item id="assets6" src="models/assets6.glb"></a-asset-item>
      <a-asset-item id="assets7" src="models/assets7.glb"></a-asset-item>
    </a-assets>

    <!-- Ambient suave (no mueve la luz principal) -->
    <a-entity light="type:ambient; intensity:0.14; color:#0b0b0b"></a-entity>

    <!-- LUZ VERDE central (mantengo posición e intensidad base; puedes ajustar intensidad si quieres) -->
    <a-entity id="greenLamp" position="0 2 0"
              light="type:point; color:#2bff7a; intensity:1.6; distance:12; decay:2; castShadow:true">
    </a-entity>

    <!-- Luz direccional de relleno (baja intensidad) -->
    <a-entity id="fillDir" position="3 4 2" rotation="-45 -30 0"
              light="type:directional; intensity:0.35; castShadow:true">
    </a-entity>

    <!-- ENTIDADES GLB (respetan transformaciones internas en cada archivo) -->
    <a-entity id="techo_ent" gltf-model="#techo" shadow="cast: false; receive: true"></a-entity>
    <a-entity id="piso_ent"  gltf-model="#piso"  shadow="cast: true; receive: true"></a-entity>
    <a-entity id="paredes_ent" gltf-model="#paredes" shadow="cast: true; receive: true"></a-entity>

    <a-entity id="asset1_ent" gltf-model="#assets1" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset2_ent" gltf-model="#assets2" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset3_ent" gltf-model="#assets3" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset4_ent" gltf-model="#assets4" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset5_ent" gltf-model="#assets5" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset6_ent" gltf-model="#assets6" shadow="cast: true; receive: true"></a-entity>
    <a-entity id="asset7_ent" gltf-model="#assets7" shadow="cast: true; receive: true"></a-entity>

    <!-- RIG / Cámara: movilidad y compatibilidad móvil -->
    <!--
         - wasd-controls: teclado en desktop
         - movement-controls (builtin A-Frame can be extended) isn't guaranteed; we keep wasd + touch-friendly look-controls
         - look-controls works on mobile with touch
    -->
    <a-entity id="rig" position="0 1.6 0">
      <a-entity id="camera" camera wasd-controls="acceleration:20" look-controls="pointerLockEnabled:false; touchEnabled:true">
        <!-- cursor opcional para desktop/touch -->
        <a-entity cursor="rayOrigin: mouse" raycaster="objects: .clickable"></a-entity>
      </a-entity>
    </a-entity>

  </a-scene>

  <script>
  (function(){
    const debugEl = document.getElementById('af-debug');
    function dbg(...args){ try { console.log(...args); if (debugEl){ debugEl.style.display='block'; debugEl.textContent = args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '); }} catch(e){} }

    const THREE = (window.AFRAME && AFRAME.THREE) ? AFRAME.THREE : window.THREE;
    const sceneEl = document.getElementById('scene');
    if (!sceneEl) { console.warn('No scene'); return; }

    // Target texture size adaptado para móvil/desktop
    const TARGET_MIN_TEX = (window.innerWidth && window.innerWidth < 800) ? 512 : 1024;
    const MAX_PIXELRATIO = Math.min(window.devicePixelRatio || 1, 1.5); // más conservador para móviles
    const SHADOW_MAP_SIZE = 1536; // calidad-media, móvil-friendly
    const SHADOW_BIAS = -0.0004;
    const SHADOW_NORMAL_BIAS = 0.02;

    function isPowerOfTwo(v){ return Number.isInteger(v) && v > 0 && (v & (v - 1)) === 0; }
    function nextPOT(v){ let p=1; while(p<v) p<<=1; return p; }

    // Solo color/emissive/alpha = sRGB. AO/light/normal/roughness/metalness = Linear.
    function preferSRGBForKey(key){
      return (key === 'map' || key === 'emissiveMap' || key === 'alphaMap');
    }

    // Renderer tuning al cargar target
    sceneEl.addEventListener('render-target-loaded', () => {
      try {
        const renderer = sceneEl.renderer;
        if (!renderer) return;
        renderer.setPixelRatio(MAX_PIXELRATIO);
        if (THREE && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        if (THREE && THREE.PCFSoftShadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        dbg('[fix] renderer configured; pixelRatio=', renderer.getPixelRatio());
      } catch(e){ console.warn('[fix] renderer config failed', e); }
    });

    // Convierte/promueve materiales básicos a MeshStandard (no roto materiales originales fuera de room clones)
    function promoteToStandard(oldMat){
      if (!oldMat) return null;
      if (oldMat.isMeshStandardMaterial) return oldMat;
      const newMat = new THREE.MeshStandardMaterial();
      const copyTexKeys = ['map','normalMap','roughnessMap','metalnessMap','aoMap','emissiveMap','alphaMap','lightMap'];
      copyTexKeys.forEach(k => { if (oldMat[k]) newMat[k] = oldMat[k]; });
      const copyFlags = ['transparent','opacity','alphaTest','vertexColors','skinning','morphTargets','flatShading','wireframe','emissiveIntensity','name','userData'];
      copyFlags.forEach(k => { if (oldMat[k] !== undefined) newMat[k] = oldMat[k]; });
      newMat.side = (oldMat.side !== undefined) ? oldMat.side : THREE.FrontSide;
      if (oldMat.color) try { newMat.color.copy(oldMat.color); } catch(e){}
      if (oldMat.emissive) try { newMat.emissive.copy(oldMat.emissive); } catch(e){}
      newMat.roughness = (oldMat.roughness !== undefined) ? oldMat.roughness : (newMat.roughness !== undefined ? newMat.roughness : 1.0);
      newMat.metalness = (oldMat.metalness !== undefined) ? oldMat.metalness : (newMat.metalness !== undefined ? newMat.metalness : 0.0);
      newMat.needsUpdate = true;
      return newMat;
    }

    // Asegura textura: encoding, mipmaps, reescalado POT si es necesario
    function ensureTextureGood(tex, key, renderer, mesh){
      if (!tex) return {ok:false, reason:'no-tex'};
      const img = tex.image;
      if (!img) return {ok:false, reason:'no-image'};
      const w = img.width || img.naturalWidth || img.bitmapWidth || 0;
      const h = img.height || img.naturalHeight || img.bitmapHeight || 0;
      const isPOT = isPowerOfTwo(w) && isPowerOfTwo(h);
      try {
        tex.encoding = preferSRGBForKey(key) && THREE && THREE.sRGBEncoding ? THREE.sRGBEncoding : THREE.LinearEncoding;
      } catch(e){}
      // AO / lightMap require uv2
      if ((key === 'aoMap' || key === 'lightMap') && mesh && mesh.geometry && !mesh.geometry.attributes.uv2) {
        return {ok:false, reason:'missing-uv2'};
      }
      // Reescalado solo si NPOT o demasiado pequeño (conservador en móvil)
      if (!isPOT || Math.max(w,h) < TARGET_MIN_TEX) {
        try {
          const maxTex = renderer.capabilities && (renderer.capabilities.maxTextureSize || 4096) || 4096;
          const desired = Math.min(maxTex, Math.max(TARGET_MIN_TEX, Math.max(w,h)));
          const target = nextPOT(desired);
          const canvas = document.createElement('canvas');
          canvas.width = target; canvas.height = target;
          const ctx = canvas.getContext('2d');
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          const aspect = (w && h) ? (w/h) : 1;
          let dw = target, dh = target;
          if (aspect > 1) dh = Math.round(target / aspect); else dw = Math.round(target * aspect);
          const ox = Math.round((target-dw)/2), oy = Math.round((target-dh)/2);
          ctx.drawImage(img, ox, oy, dw, dh);
          const newTex = new THREE.CanvasTexture(canvas);
          newTex.generateMipmaps = true;
          newTex.minFilter = THREE.LinearMipmapLinearFilter;
          newTex.magFilter = THREE.LinearFilter;
          try { const maxAniso = renderer.capabilities && (renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1) || 1; newTex.anisotropy = maxAniso; } catch(e){ newTex.anisotropy = 1; }
          newTex.wrapS = tex.wrapS || THREE.ClampToEdgeWrapping;
          newTex.wrapT = tex.wrapT || THREE.ClampToEdgeWrapping;
          if (tex.flipY !== undefined) newTex.flipY = tex.flipY;
          if (tex.premultiplyAlpha !== undefined) newTex.premultiplyAlpha = tex.premultiplyAlpha;
          if (tex.format !== undefined) newTex.format = tex.format;
          newTex.encoding = preferSRGBForKey(key) && THREE && THREE.sRGBEncoding ? THREE.sRGBEncoding : THREE.LinearEncoding;
          newTex.needsUpdate = true;
          return {ok:true, replaced:true, newTex};
        } catch(e){ return {ok:false, reason:'canvas-resize-failed', err:e}; }
      }
      // otherwise mark ok
      try {
        tex.generateMipmaps = true;
        tex.minFilter = tex.minFilter || THREE.LinearMipmapLinearFilter;
        tex.magFilter = tex.magFilter || THREE.LinearFilter;
        tex.anisotropy = tex.anisotropy || (renderer.capabilities && renderer.capabilities.getMaxAnisotropy && renderer.capabilities.getMaxAnisotropy()) || 1;
        tex.needsUpdate = true;
      } catch(e){}
      return {ok:true, replaced:false, info:{w,h,isPOT}};
    }

    // Heurístico para detectar mesh grande (habitacion)
    function detectRoomCandidates(root){
      const meshes = [];
      root.traverse(node => { if (node.isMesh) meshes.push(node); });
      if (!meshes.length) return [];
      const byName = meshes.filter(m => m.name && /floor|piso|ground|suelo|tile|wall|ceiling|techo|room|hab/i.test(m.name));
      if (byName.length) return byName;
      const areas = meshes.map(m=>{
        const bb = new THREE.Box3().setFromObject(m);
        const s = new THREE.Vector3(); bb.getSize(s);
        const area = Math.abs(s.x * s.z) || Math.abs(s.x*s.y) || Math.abs(s.y*s.z);
        return {m, area};
      }).sort((a,b)=>b.area-a.area);
      return areas.slice(0,1).map(x=>x.m);
    }

    // Inspección y corrección segura por modelo
    function inspectAndFixModel(el){
      if (!el) return;
      const renderer = sceneEl.renderer;
      function onModelLoaded(ev){
        try {
          const root = ev.detail && ev.detail.model ? ev.detail.model : (el.getObject3D('mesh') || el.getObject3D('model'));
          if (!root) return;
          dbg('[fix] inspecting', el.id || el);
          const fixes = [];
          const roomCandidates = detectRoomCandidates(root);
          const roomSet = new Set(roomCandidates);

          root.traverse(node => {
            if (!node.isMesh) return;

            // normals
            if (node.geometry && !node.geometry.attributes.normal) {
              try { node.geometry.computeVertexNormals(); fixes.push({type:'computedNormals', mesh: node.name || node.id}); } catch(e){}
            }

            // material handling: work on clones for room meshes to avoid changing shared mats
            let mats = Array.isArray(node.material) ? node.material.slice() : [node.material];
            let treatAsRoom = roomSet.has(node);

            if (!treatAsRoom) {
              try {
                const bb = new THREE.Box3().setFromObject(node);
                const s = new THREE.Vector3(); bb.getSize(s);
                const area = Math.abs(s.x * s.z);
                if (area > 1.0) treatAsRoom = true;
              } catch(e){}
            }

            if (treatAsRoom) {
              mats = mats.map(m => { if (!m) return m; try { return m.clone ? m.clone() : Object.assign(Object.create(Object.getPrototypeOf(m)), m); } catch(e){ return m; } });
              node.material = Array.isArray(node.material) ? mats : mats[0];
              fixes.push({type:'clonedMatsForRoom', mesh: node.name || node.id});
            }

            // iterate materials
            mats.forEach((mat, idx) => {
              if (!mat) return;

              // promote old materials
              if (mat.isMeshBasicMaterial || mat.isMeshLambertMaterial || mat.isMeshPhongMaterial) {
                const promoted = promoteToStandard(mat);
                if (promoted) {
                  if (Array.isArray(node.material)) node.material[idx] = promoted;
                  else node.material = promoted;
                  mat = promoted;
                  fixes.push({type:'promotedMaterial', mesh: node.name || node.id});
                }
              }

              // check maps
              ['map','emissiveMap','lightMap','aoMap','normalMap','metalnessMap','roughnessMap','alphaMap'].forEach(k => {
                if (node.material && node.material[k]) {
                  const res = ensureTextureGood(node.material[k], k, renderer, node);
                  if (res.ok && res.replaced && res.newTex) {
                    try { if (node.material[k] && node.material[k].dispose) node.material[k].dispose(); } catch(e){}
                    node.material[k] = res.newTex;
                    node.material.needsUpdate = true;
                    fixes.push({type:'replacedTexture', mesh: node.name || node.id, key:k});
                    dbg('[fix] replaced texture', k, 'on', node.name || node.id);
                  } else if (!res.ok) {
                    if (res.reason === 'missing-uv2') {
                      node.material[k] = null;
                      node.material.needsUpdate = true;
                      fixes.push({type:'removedMapMissingUV2', mesh: node.name || node.id, key:k});
                      dbg('[fix] removed', k, 'due missing uv2 on', node.name || node.id);
                    } else {
                      fixes.push({type:'texProblem', mesh: node.name || node.id, key:k, reason: res.reason || ''});
                    }
                  }
                }
              });

              // flags: opacity / transparent / depthWrite
              try {
                if (mat.opacity !== undefined && mat.opacity >= 0.999) {
                  if (mat.transparent) { mat.transparent = false; fixes.push({type:'transparentDisabled', mesh: node.name || node.id}); }
                  if (mat.depthWrite === false) { mat.depthWrite = true; fixes.push({type:'depthWriteEnabled', mesh: node.name || node.id}); }
                } else {
                  if (mat.transparent) {
                    if (mat.alphaTest === undefined || mat.alphaTest > 0.05) {
                      const old = mat.alphaTest || 0;
                      mat.alphaTest = Math.min(0.05, old || 0.05);
                      fixes.push({type:'alphaTestAdjusted', mesh: node.name || node.id});
                    }
                  }
                }
              } catch(e){}

              // polygonOffset to mitigate z-fighting/shadow acne
              try {
                if (!mat.polygonOffset) {
                  mat.polygonOffset = true;
                  mat.polygonOffsetFactor = (mat.polygonOffsetFactor !== undefined) ? mat.polygonOffsetFactor : 1;
                  mat.polygonOffsetUnits = (mat.polygonOffsetUnits !== undefined) ? mat.polygonOffsetUnits : 3;
                  fixes.push({type:'polygonOffsetApplied', mesh: node.name || node.id});
                }
              } catch(e){}

              // if room, make cloned material double sided (safe)
              if (treatAsRoom) {
                try {
                  mat.side = THREE.DoubleSide;
                  if (mat.opacity !== undefined && mat.opacity >= 0.999) {
                    mat.transparent = false;
                    mat.depthWrite = true;
                  }
                  mat.needsUpdate = true;
                  fixes.push({type:'roomMatDoubleSided', mesh: node.name || node.id});
                } catch(e){}
              }
            });

            // Shadows by default unless opted out
            if (!(node.userData && node.userData.noShadow)) {
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });

          dbg('[fix] issues found/fixed for', el.id, fixes.length ? fixes : 'none');
        } catch(e){ console.warn('[fix] model inspect failed for', el.id, e); }
      }

      el.addEventListener('model-loaded', onModelLoaded, { once: true });

      // if model already loaded, fire immediately
      const maybe = el.getObject3D('mesh') || el.getObject3D('model');
      if (maybe) el.emit('model-loaded', { model: maybe }, false);
    }

    // Ajusta parámetros de sombras para cada luz importante
    function tuneLightShadows(elId, opts){
      const ent = document.getElementById(elId);
      if (!ent) return;
      ent.addEventListener('object3dset', () => {
        try {
          const light = ent.getObject3D('light');
          if (!light) return;
          light.castShadow = true;
          const maxAllowed = (sceneEl.renderer && sceneEl.renderer.capabilities && sceneEl.renderer.capabilities.maxTextureSize) || 2048;
          const wanted = Math.min(SHADOW_MAP_SIZE, maxAllowed);
          if (light.shadow && light.shadow.mapSize) {
            light.shadow.mapSize.width = wanted;
            light.shadow.mapSize.height = wanted;
          }
          if (light.shadow) light.shadow.bias = (opts && opts.bias !== undefined) ? opts.bias : SHADOW_BIAS;
          if ('normalBias' in light) light.normalBias = (opts && opts.normalBias !== undefined) ? opts.normalBias : SHADOW_NORMAL_BIAS;
          if (light.shadow && 'radius' in light.shadow) light.shadow.radius = (opts && opts.radius !== undefined) ? opts.radius : 2.5;
          if (light.shadow && light.shadow.camera && light.shadow.camera.updateProjectionMatrix) {
            try { if (opts && opts.near !== undefined) light.shadow.camera.near = opts.near; if (opts && opts.far !== undefined) light.shadow.camera.far = opts.far; light.shadow.camera.updateProjectionMatrix(); } catch(e){}
          }
          dbg('[fix] tuned shadows for', elId);
        } catch(e){ console.warn('[fix] tuneLightShadows fail', e); }
      }, { once: true });
    }

    // Apply inspection for all gltf-model entities
    const nodes = sceneEl.querySelectorAll('[gltf-model]');
    nodes.forEach(n => inspectAndFixModel(n));

    // Set up lights shadow tuning
    tuneLightShadows('greenLamp', { bias: -0.0004, normalBias: 0.02, radius: 2.5, near: 0.1, far: 20 });
    tuneLightShadows('fillDir', { bias: -0.0005, normalBias: 0.02, radius: 2.0, near: 0.5, far: 50 });

    // Ensure loaded models set mesh shadow flags
    sceneEl.addEventListener('model-loaded', (evt) => {
      try {
        const el = evt.target;
        if (!el) return;
        const obj = el.getObject3D('mesh') || el.getObject3D('model');
        if (!obj) return;
        obj.traverse(node => { if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; } });
      } catch(e){ console.warn('[cfg] model-loaded handling error', e); }
    });

    // Scene-wide fallback pass (reapply encodings, small fallbacks)
    function applySceneFallbacks(){
      try {
        let adjusted = 0;
        sceneEl.object3D.traverse(node => {
          if (!node.isMesh) return;
          const mats = Array.isArray(node.material) ? node.material : [node.material];
          mats.forEach(m => {
            if (!m) return;
            // reapply encodings conservatively
            ['map','emissiveMap','alphaMap'].forEach(k=>{ if (m[k] && m[k].encoding !== THREE.sRGBEncoding){ try{ m[k].encoding = THREE.sRGBEncoding; m[k].needsUpdate = true; adjusted++; }catch(e){} }});
            ['aoMap','lightMap','normalMap','roughnessMap','metalnessMap'].forEach(k=>{ if (m[k] && m[k].encoding !== THREE.LinearEncoding){ try{ m[k].encoding = THREE.LinearEncoding; m[k].needsUpdate = true; adjusted++; }catch(e){} }});
            // fallback color for large meshes without texture
            try {
              const bb = new THREE.Box3().setFromObject(node); const s = new THREE.Vector3(); bb.getSize(s);
              const area = Math.abs(s.x * s.z) || Math.abs(s.x*s.y) || Math.abs(s.y*s.z);
              if (area > 0.8) {
                if (!m.map && m.color && m.color.getHex && m.color.getHex() === 0x000000) {
                  m.color.setHex(0x888888); m.transparent = false; m.depthWrite = true; m.needsUpdate = true; adjusted++;
                }
              }
            } catch(e){}
          });
        });
        if (adjusted) dbg('[fallback] adjustments:', adjusted);
      } catch(e){ console.warn('[fallback] error', e); }
    }

    // run fallback shortly after models inspected
    setTimeout(applySceneFallbacks, 1200);

    // Debug helpers exposed to console
    window.__aframe_debug = {
      toggleWireframe: function(state){
        sceneEl.object3D.traverse(node=>{
          if (node.isMesh && node.material){
            const mats = Array.isArray(node.material) ? node.material : [node.material];
            mats.forEach(m=>{ if (m){ m.wireframe = (state===undefined) ? !m.wireframe : !!state; m.needsUpdate=true; } });
          }
        });
        console.log('[debug] toggleWireframe', state);
      },
      listMaterials: function(){
        const out = [];
        sceneEl.object3D.traverse(n => {
          if (n.isMesh && n.material) {
            const mats = Array.isArray(n.material) ? n.material : [n.material];
            mats.forEach(m => {
              if (!m) return;
              out.push({
                mesh: n.name || n.id,
                side: m.side,
                transparent: m.transparent,
                opacity: m.opacity,
                alphaTest: m.alphaTest,
                map: !!m.map,
                aoMap: !!m.aoMap,
                lightMap: !!m.lightMap,
                roughnessMap: !!m.roughnessMap,
                metalnessMap: !!m.metalnessMap
              });
            });
          }
        });
        console.log(out);
        return out;
      },
      // Forzador de material visible en el mesh de mayor área (diagnóstico)
      forceRoomMaterial: function(){
        const ent = document.getElementById('paredes_ent') || document.getElementById('piso_ent') || document.getElementById('techo_ent');
        if (!ent) { console.warn('No entity for forceRoomMaterial'); return; }
        const root = ent.getObject3D('mesh') || ent.getObject3D('model');
        if (!root) { console.warn('Modelo no listo'); return; }
        let best = null; let bestA = 0;
        root.traverse(n => {
          if (!n.isMesh) return;
          const bb = new THREE.Box3().setFromObject(n); const s = new THREE.Vector3(); bb.getSize(s);
          const area = Math.abs(s.x * s.z) || Math.abs(s.x*s.y) || Math.abs(s.y*s.z);
          if (area > bestA) { bestA = area; best = n; }
        });
        if (!best) { console.warn('No mesh encontrado'); return; }
        console.log('forceRoomMaterial -> mesh:', best.name || best.id, 'area', bestA);
        try {
          const baseMap = best.material && (Array.isArray(best.material) ? best.material[0].map : best.material.map);
          let testMat;
          if (baseMap) testMat = new THREE.MeshStandardMaterial({ map: baseMap, side: THREE.DoubleSide });
          else testMat = new THREE.MeshStandardMaterial({ color: 0x888888, side: THREE.DoubleSide });
          if (Array.isArray(best.material)) best.material = best.material.map(_=> testMat); else best.material = testMat;
          best.material.needsUpdate = true;
          best.castShadow = true; best.receiveShadow = true;
          console.log('forceRoomMaterial applied; verifica si la geometría aparece.');
        } catch(e){ console.warn('forceRoomMaterial failed', e); }
      }
    };

    dbg('[fix] Diagnostics loaded — usa __aframe_debug.* en la consola.');
  })();
  </script>
</body>
</html>
